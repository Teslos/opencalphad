!
! included in pmod25.F90
!
!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\
!>     10. List things
!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_all_elements(unit)
! lists elements
   implicit none
   integer unit
!\end{verbatim} %+
   integer jl,ipos
   character line*80
   line=' '
   write(unit,10)
10  format(/'List of elements'/ &
        ' No Sym Name',10X,'Reference state',12X,&
        'Mass  H298-H0   S298    Status')
   loop1: do jl=-1,noofel
      ipos=1
      call list_element_data(line,ipos,elements(jl))
      if(gx%bmperr.ne.0) goto 1000
      write(unit,100)jl,line(1:ipos)
   enddo loop1
100 format(i3,2x,A)
1000 continue
   return
 END subroutine list_all_elements

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim} %-
 subroutine list_all_elements2(unit)
! lists elements
   implicit none
   integer unit
!\end{verbatim}
   integer jl
   character line*80
   line=' '
   loop1: do jl=-1,noofel
      write(unit,100) ellista(jl)%symbol,ellista(jl)%ref_state,&
           ellista(jl)%mass,ellista(jl)%h298_h0,ellista(jl)%s298
   enddo loop1
100 format('ELEMENT ',A,'  ',A,3(1pe12.4),' !')
1000 continue
   return
 END subroutine list_all_elements2

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_all_components(unit,ceq)
! lists the components for an equilibrium
   implicit none
   integer unit
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   integer jl,loksp
   character symbol*24
   double precision moles,masspercent,chempot
   moles=zero
   masspercent=zero
   chempot=zero
   write(unit,10)
10  format('List of components'/ &
        'No Symbol',19X,'Moles',6x,'Mass %',5x,'Chem pot',3x,'Ref. state')
   loop1: do jl=1,noofel
      loksp=ceq%complist(jl)%splink
      symbol=splista(loksp)%symbol
      write(unit,100)jl,symbol,moles,masspercent,chempot,&
           ceq%complist(jl)%refstate
   enddo loop1
100 format(i2,1x,A,3(1PE11.3),1X,A)
1000 continue
   return
 end subroutine list_all_components

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_element_data(text,ipos,elno)
   implicit none
   character text*(*)
   integer ipos,elno
!\end{verbatim}
   if(elno.lt.-1 .or. elno.gt.noofel) then
      gx%bmperr=4042
      goto 1000
   endif
   if(ipos.lt.1 .or. ipos.ge.len(text)) then
      gx%bmperr=4043
      goto 1000
   endif
   text(ipos:ipos+2)=ellista(elno)%symbol
   text(ipos+3:ipos+16)=ellista(elno)%name
   text(ipos+17:ipos+40)=ellista(elno)%ref_state
   write(text(ipos+41:ipos+73),100)ellista(elno)%mass,&
        ellista(elno)%h298_h0,ellista(elno)%s298,ellista(elno)%status
100 format(1x,f7.3,1x,f7.2,1x,f7.3,1x,z8)
   ipos=len_trim(text)
!   write(*,*)'x:',text(1:79)
1000 continue
   return
 END subroutine list_element_data

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_species_data(text,ipos,spno)
   implicit none
   character text*(*)
   integer ipos,spno
!\end{verbatim} %+
   character dummy*48
   integer jpos
   if(spno.lt.1 .or. spno.gt.noofsp) then
!       write(*,*)'in list_species_data'
      gx%bmperr=4051
      goto 1000
   endif
   if(ipos.lt.1 .or. ipos.ge.len(text)) then
      gx%bmperr=4043
      goto 1000
   endif
   text(ipos:ipos+24)=splista(spno)%symbol
   text(ipos+25:ipos+25)=' '
   dummy=' '
   call encode_stoik(dummy,jpos,spno)
   text(ipos+26:ipos+48)=dummy(1:min(23,jpos))
   if(jpos.gt.23) text(ipos+46:ipos+48)='<.>'
   text(ipos+49:ipos+49)=' '
   write(text(ipos+50:ipos+59),100)splista(spno)%mass
   write(text(ipos+60:ipos+65),105)splista(spno)%charge
100 format(F10.3)
105 format(F6.1)
   text(ipos+66:)=' '
!    write(*,120)splista(spno)%status
   write(text(ipos+66:ipos+73),120)splista(spno)%status
120 format(Z8)
   ipos=ipos+73
1000 continue
   return
 END subroutine list_species_data

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim} %-
 subroutine list_species_data2(text,ipos,spno)
   implicit none
   character text*(*)
   integer ipos,spno
!\end{verbatim}
   character dummy*24
   integer jpos
   if(spno.lt.1 .or. spno.gt.noofsp) then
!       write(*,*)'in list_species_data'
      gx%bmperr=4051
      goto 1000
   endif
   if(ipos.lt.1 .or. ipos.ge.len(text)) then
      gx%bmperr=4043
      goto 1000
   endif
   text(ipos:ipos+24)=splista(spno)%symbol
   text(ipos+25:ipos+25)=' '
   dummy=' '
   call encode_stoik(dummy,jpos,spno)
   text(ipos+26:ipos+48)=dummy(1:jpos)
!   text(ipos+49:ipos+49)=' '
!   write(text(ipos+50:ipos+59),100)splista(spno)%mass
!   write(text(ipos+60:ipos+65),105)splista(spno)%charge
100 format(F10.3)
105 format(F6.1)
!   text(ipos+66:)=' '
!    write(*,120)splista(spno)%status
!   write(text(ipos+66:ipos+73),120)splista(spno)%status
120 format(Z8)
!   ipos=ipos+73
1000 continue
   return
 END subroutine list_species_data2

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_all_species(unit)
   implicit none
   integer unit
!\end{verbatim}
   integer jl,ipos
   character line*80
   write(unit,10)
10  format(/'List of species'/ &
        '  No Symbol',20X,'Stoichiometry',12X,'Mass      Charge Status')
   loop1: do jl=1,noofsp
      ipos=1
      call list_species_data(line,ipos,species(jl))
      if(gx%bmperr.ne.0) goto 1000
      write(unit,100)jl,line(1:ipos)
   enddo loop1
100 format(i4,1x,A)
1000 continue
   return
 END subroutine list_all_species

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_all_phases(unit,ceq)
! short list with one line for each phase
   implicit none
   integer unit
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
! separate entered/fixed form suspended/dormant
   integer jl,jk,ics,lokph,lokcs,kp,ndorm
   character line*80,phname*24,trailer*28,chs*1,csname*36
!   type(gtp_phasetuple), allocatable :: dormant
   TYPE(gtp_phase_varres), pointer :: csrec
   write(unit,10)
10  format(/'List of entered phases'/ &
        '  No tup Name',22x,'Mol.comp.  At/F.U.  dGm/RT   Status1 Status2')
   jl=0
   trailer=' '
!   write(*,*)'In list_all_phases',noofph
!   allocate(dormant(noofph))
!   dormant=0
   ndorm=0
! come back here with dormant listing
20 continue
!
   phloop: do jk=1,noofph
      line=' '
! list in alphabetical order except gas and liquid first
      lokph=phases(jk)
      csloop: do ics=1,phlista(lokph)%noofcs
         lokcs=phlista(lokph)%linktocs(ics)
         csrec=>ceq%phase_varres(lokcs)
!         write(*,*)'lpd: 69: ',jk,ics,lokph,lokcs
         if(ndorm.ge.0) then
            if(csrec%phstate.le.PHDORM) then
               ndorm=ndorm+1
!               dormant%phase=jk
!               dormant%compset=ics
               cycle
            endif
         elseif(csrec%phstate.gt.PHDORM) then
            cycle
         endif
         phname=phlista(lokph)%name
         jl=jl+1
!         write(*,70)'lpd: 70:',phname,phlista(lokph)%noofcs
!70       format(a,a24,5i6)
         if(phlista(lokph)%noofcs.gt.1) then
            chs=char(ichar('0')+ics)
            kp=len_trim(csrec%prefix)
            if(kp.gt.0) then
               csname=csrec%prefix(1:kp)//'_'//phname
            else
               csname=phname
            endif
            kp=len_trim(csrec%suffix)
            if(kp.gt.0) &
                 csname=csname(1:len_trim(csname))//'_'//csrec%suffix(1:kp)
            csname=csname(1:len_trim(csname))//'#'//chs//trailer
         else
            csname=phname
         endif
! phase names for composition sets can be larger than 24
         jl=len_trim(csname)
         if(jl.gt.24) then
            csname=csname(1:12)//'..'//csname(jl-9:jl)
         endif
         if(csrec%amfu.ne.zero) then
            if(csrec%dgm.eq.zero) then
!               write(unit,110)jk,ics,csname, &
               write(unit,110)jk,csrec%phtupx,csname, &
                    csrec%amfu*csrec%abnorm(1),&
                    csrec%abnorm(1),&
                    phlista(lokph)%status1,ceq%phase_varres(lokcs)%status2
110            format(2i4,1x,a24,1PE10.2,1x,0PF9.2,'       0.0',2(0p,z8))
            else
!               write(unit,112)jk,ics,csname, &
               write(unit,112)jk,csrec%phtupx,csname, &
                    csrec%amfu*csrec%abnorm(1),&
                    csrec%abnorm(1),csrec%dgm,&
                    phlista(lokph)%status1,ceq%phase_varres(lokcs)%status2
112            format(2i4,1x,a24,1PE10.2,1x,0PF9.2,1PE10.2,2(0p,z8))
            endif
         else
!            write(unit,111)jk,ics,csname, &
            write(unit,111)jk,csrec%phtupx,csname, &
                 csrec%abnorm(1),csrec%dgm,&
                 phlista(lokph)%status1,ceq%phase_varres(lokcs)%status2
111         format(2i4,1x,a24,'       0.0',1x0PF9.2,1PE10.2,2(0p,z8))
         endif
      enddo csloop
   enddo phloop
   if(ndorm.le.0) goto 1000
   write(unit,200)
200 format(/'List of dormant/suspended phases'/ &
         '  No tup Name',22x,'Mol.comp.  At/F.U.  dGm/RT   Status1 Status2')
   ndorm=-1
   goto 20

1000 continue
! temporary list all phase tuples
!   do jl=1,nooftuples
!      lokph=phases(phasetuple(jl)%phase)
!      lokcs=phlista(lokph)%linktocs(phasetuple(jl)%compset)
!      write(*,600)jl,phasetuple(jl)%phase,phasetuple(jl)%compset,lokcs,&
!           firsteq%phase_varres(lokcs)%phtupx
!600   format('Phase tuple: ',3i4,' backlink: ',5i4)
!   enddo
   return
 END subroutine list_all_phases

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_global_results(lut,ceq)
! list G, T, P, V and some other things
   implicit none
   integer lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   character encoded*64
   double precision x1,x2,x3,xn,rtn
   call get_state_var_value('T ',x1,encoded,ceq)
   call get_state_var_value('P ',x2,encoded,ceq)
   call get_state_var_value('V ',x3,encoded,ceq)
   if(gx%bmperr.ne.0) goto 1000
   write(lut,10)x1,x1-273.15,x2,x3
10 format('T= ',F9.2,' K (',F9.2,' C), P= ',1pe11.4,&
        ' Pa, V= ',1pe11.4,' m3')
   rtn=globaldata%rgas*x1
! problem with N, should not take into account the atoms/formula units?
   call get_state_var_value('N ',xn,encoded,ceq)
   call get_state_var_value('B ',x2,encoded,ceq)
   if(gx%bmperr.ne.0) goto 1000
   write(lut,11)xn,x2,rtn
11 format('N= ',1pe12.4,' moles, B= ',1pe12.4,' g, RT= ',1pe12.4,' J/mol')
   call get_state_var_value('G ',x1,encoded,ceq)
   call get_state_var_value('H ',x2,encoded,ceq)
   call get_state_var_value('S ',x3,encoded,ceq)
   if(gx%bmperr.ne.0) goto 1000
   write(lut,12)x1,x1/xn,x2,x3
12 format('G= ',1pe11.4,' J, G/N= ',1pe11.4,' J/mol, H= ',1pe11.4,&
        ' J, S= ',1pe11.4,' J/K')
1000 continue
   return
 end subroutine list_global_results

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_components_result(lut,mode,ceq)
! list one line per component (name, moles, x/w-frac, chem.pot. reference state
! mode 1=mole fractions, 2=mass fractions
   implicit none
   integer lut,mode
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   character svtext*64,encoded*64,name*24
   integer ie,kl
   double precision x1,x2,x3,x4,rtn
   if(mode.eq.1) then
      write(lut,7)
!7     format('Component name',11x,'Moles',7x,'Mole-fracs  Chem.potent. ',&
7     format('Component name',4x,'Moles',6x,'Mole-fr  Chem.pot/RT  ',&
           'Activities  Ref.state')
   elseif(mode.eq.2) then
      write(lut,9)
9     format('Component name',4x,'Moles',6x,'Mass-fr  Chem.pot/RT  ',&
           'Activities  Ref.state')
   endif
   call get_state_var_value('T ',x1,encoded,ceq)
   rtn=globaldata%rgas*x1
   do ie=1,noofel
      call get_component_name(ie,name,ceq)
      kl=len_trim(name)
      svtext='N('//name(1:kl)//') '
!      write(*,*)'state variable :',svtext
      call get_state_var_value(svtext,x1,encoded,ceq)
      if(gx%bmperr.ne.0) goto 1000
!
      if(mode.eq.1) then
         svtext='X('//name(1:kl)//') '
      elseif(mode.eq.2) then
         svtext='W('//name(1:kl)//') '
      endif
      call get_state_var_value(svtext,x2,encoded,ceq)
      if(gx%bmperr.ne.0) goto 1000
! This should be read from component record .... ???? YES
      svtext='MU('//name(1:kl)//') '
!      write(*,*)'state variable :',svtext
      call get_state_var_value(svtext,x3,encoded,ceq)
! divide mu with RT
      x3=x3/rtn
      x4=exp(x3)
      if(gx%bmperr.ne.0) then
         write(*,*)'25E Error: ',gx%bmperr
         gx%bmperr=0; x3=1.0D36
      endif
! reference state, by default "SER (default)" take from component record
!      if(ceq%complist(ie)%phlink.gt.0) then
      encoded=ceq%complist(ie)%refstate
!      else
! default name of reference state
!         encoded='SER (default)'
!      endif
      write(lut,10)name(1:16),x1,x2,x3,x4,encoded(1:16)
!10    format(a,3(1pe12.4),2x,a)
10    format(a,1pe12.4,0pf9.5,2(1pe12.4),2x,a)
   enddo
1000 continue
   return
 end subroutine list_components_result

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_phases_with_positive_dgm(mode,lut,ceq)
! list one line for each phase+comp.set with positive dgm on device lut
! The phases must be dormant or the result is in error.  mode is not used
   implicit none
   integer mode,lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   character name*24
!   character*10, dimension(-3:2) :: status=&
!        ['SuspendedEntered   ','Fix       ','Dormant   ','Suspended ']
   integer once,iph,lokph,ics,lokcs,kkz
   double precision xxx
   once=0
   do iph=1,noofph
      lokph=phases(iph)
      csloop: do ics=1,phlista(lokph)%noofcs
         lokcs=phlista(lokph)%linktocs(ics)
         if(ceq%phase_varres(lokcs)%phstate.lt.PHDORM) cycle csloop
         if(abs(ceq%phase_varres(lokcs)%netcharge).gt.1.0d-6) then
!            write(*,*)'ignoring phase with net charge: ',iph,ics
            cycle csloop
         endif
         if(ceq%phase_varres(lokcs)%dgm.gt.1.0D-12) then
            if(once.eq.0) then
               once=1
               write(lut,110)
110            format(/' *** Phases which would like to be stable:')
            endif
            call get_phase_name(iph,ics,name)
            kkz=test_phase_status(iph,ics,xxx,ceq)
!            write(*,*)'25E: error: ',name,lokcs,kkz
! old kkz.le.2 means entered or fixed
!            if(kkz.le.3) then
! now: kkz= -3,    -2,         -1,         0,           1,         2 
! means SUSPEND, DORMANT, ENTENTED/UNST, ENTERED, ENTERD/STABLE, FIXED
            if(kkz.ge.PHDORM) then
               write(lut,120)name,phstate(kkz),ceq%phase_varres(lokcs)%dgm
120            format('Phase: ',a,' Status: ',a,' Driving force:',1pe12.4)
            endif
         endif
      enddo csloop
   enddo
1000 continue
   return
 end subroutine list_phases_with_positive_dgm

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_phase_results(iph,jcs,mode,lut,ceq)
! list results for a phase+comp.set on lut
! mode specifies the type and amount of results,
! unit digit:   0=mole fraction,      othewise mass fractions
! 10th digit:   0=only composition,   10=also constitution
! 100th digit:  0=value order,        100=alphabetical order
! 1000th digit: 0=only stable phases, 1000=all phases
   implicit none
   integer iph,jcs,mode,lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   character text*256,phname*24,status*10
   character (len=24), dimension(:), allocatable :: consts
!    character*24, allocatable (:) :: consts
   double precision xmol(maxel),wmass(maxel),totmol,totmass,amount,abv,mindgm
   double precision, dimension(:), allocatable :: ymol
   integer lokph,lokcs,kode,nz,jl,nk,ll,ip,kstat
   mindgm=1.0D-10
   if(ocv()) write(*,*)'mode: ',mode
   if(iph.lt.1 .or. iph.gt.noofph) then
!       write(*,*)'lpr ',iph,jcs,mode
      gx%bmperr=4050; goto 1000
   endif
   lokph=phases(iph)
   if(btest(phlista(lokph)%status1,phhid)) then
! phase is hidden
      gx%bmperr=4119; goto 1000
   endif
!
! .gt.9
!
   if(jcs.lt.0 .or. jcs.gt.phlista(lokph)%noofcs) then
      gx%bmperr=4072; goto 1000
   elseif(jcs.eq.0) then
      jcs=1
   endif
   lokcs=phlista(lokph)%linktocs(jcs)
!   write(*,*)'lpr 2: ',jcs,phlista(lokph)%noofcs,lokcs
! get name with pre- and suffix
   call get_phase_name(iph,jcs,phname)
   if(gx%bmperr.ne.0) goto 1000
!   write(*,11)'Phase name: ',iph,jcs,phname
!11 format(a,2i3,'"',a,'"')
   if(mode.ge.1000) then
! if mode>=1000 list stable phases only (dgm<0 )
!      if(ceq%phase_varres(lokcs)%amount(1).eq.zero) then
      if(abs(ceq%phase_varres(lokcs)%netcharge).gt.1.0d-6) goto 1000
      if(ceq%phase_varres(lokcs)%amfu.eq.zero) then
! skip phases with zero amount unless expcitly stable or positive dgm
         if(ceq%phase_varres(lokcs)%dgm.eq.zero) then
!            if(ceq%phase_varres(lokcs)%phstate.ne.PHFIXED) goto 1000
            if(ceq%phase_varres(lokcs)%phstate.lt.PHENTSTAB) goto 1000
         elseif(ceq%phase_varres(lokcs)%dgm.lt.mindgm) then
            goto 1000
         endif
      endif
   endif
! phase status (except hidden) .... use get_phase_status instead ???
!   if(btest(ceq%phase_varres(lokcs)%status2,cssus)) then
!      if(btest(ceq%phase_varres(lokcs)%status2,csfixdorm)) then
   if(ceq%phase_varres(lokcs)%phstate.eq.PHDORM) then
      status='Dormant'
      kstat=4
! skip dormant phases unless positive driving force
!      if(ceq%phase_varres(lokcs)%dgm.le.mindgm) goto 1000
   elseif(ceq%phase_varres(lokcs)%phstate.eq.PHSUS) then
! skip suspended phases
      status='Suspended'
      goto 1000
!      if(btest(ceq%phase_varres(lokcs)%status2,csfixdorm)) then
   elseif(ceq%phase_varres(lokcs)%phstate.eq.PHFIXED) then
      status='Fixed'
      kstat=2
   else
      status='Entered'
      kstat=1
! skip phase with net charge
!      if(abs(ceq%phase_varres(lokcs)%netcharge).gt.1.0D-6) goto 1000
! skip entered phases that have positive driving force, why??
!      if(ceq%phase_varres(lokcs)%dgm.gt.zero) goto 1000
   endif
   if(phname(1:1).lt.'A' .or. phname(1:1).gt.'Z') then
! in some cases unprintable phase names appears!!
      write(lut,19)iph,jcs,lokph,lokcs
19    format('Illegal  phase name: ',10i5)
   endif
   write(lut,20)phname,status,ceq%phase_varres(lokcs)%dgm
20  format(/'Phase: ',A,' Status: 'A,' Driving force: ',1PE12.4)
!------------------------
!   xmol=zero
!   wmass=zero
   call calc_phase_molmass(iph,jcs,xmol,wmass,totmol,totmass,amount,ceq)
   if(gx%bmperr.ne.0) then
      write(*,*)'Error: ',gx%bmperr; goto 1000
   endif
!   write(*,99)'xmol: ',xmol
!99 format(a,6(1pe12.4))
   kode=mod(mode,10)
!   write(*,*)'lpr: ',mode,kode
   abv=ceq%phase_varres(lokcs)%abnorm(1)
   if(kode.eq.0) then
! The volume value here is WRONG: ceq%phase_varres(lokcs)%gval(3,1) !!! ???
      if(abs(ceq%phase_varres(lokcs)%netcharge).gt.1.0D-6) then
         write(lut,28)totmol,totmass*0.001, &
              amount*ceq%rtn*ceq%phase_varres(lokcs)%gval(3,1),&
              ceq%phase_varres(lokcs)%netcharge
      else
         write(lut,25)totmol,totmass*0.001, &
              amount*ceq%rtn*ceq%phase_varres(lokcs)%gval(3,1)
      endif
      write(lut,21)ceq%phase_varres(lokcs)%amfu,abv
21    format('Formula Units: ',1pe12.4,', Moles of atoms/FU: ',1pe12.4,&
           ', Molar content:')
   else
      write(lut,25)totmol,totmass*0.001,&
           amount*ceq%rtn*ceq%phase_varres(lokcs)%gval(3,1)
      write(lut,22)ceq%phase_varres(lokcs)%amfu,abv
22    format('Formula Units: ',1pe12.4,', Moles of atoms/FU: ',1pe12.4,&
           ', Mass fractions:')
   endif
25  format('Moles',1PE12.4,', Mass',1PE12.4,' kg, Volume',1PE12.4,' m3')
28  format('Moles',1PE12.4,', Mass',1PE12.4,' kg, Volume',1PE12.4,' m3',&
         ' Charge: ',1pe10.2)
! composition
   nz=noofel
   allocate(consts(nz))
   consts=' '
   do jl=1,nz
      consts(jl)=splista(ceq%complist(jl)%splink)%symbol
   enddo
!    write(*,187)'lpr: ',consts
!187 format(a,20(1x,a2))
   if(kode.eq.0) then
      call format_phase_composition(mode,nz,consts,xmol,lut)
   else
      call format_phase_composition(mode,nz,consts,wmass,lut)
   endif
   deallocate(consts)
   if(gx%bmperr.ne.0) goto 1000
!-------------------------------------
! constitution only if nonzero tenth-digit of mode or if GAS
300 continue
   if(.not.btest(phlista(lokph)%status1,PHGAS)) then
      if(mod(mode/10,10).le.0) goto 1000
   endif
   write(lut,310)
310  format('Constitution: ')
!---------------
   nk=0
   sublatloop: do ll=1,phlista(lokph)%noofsubl
      nz=phlista(lokph)%nooffr(ll)
      if(phlista(lokph)%noofsubl.gt.1) then
!         write(lut,320)ll,nz,phlista(lokph)%sites(ll)
         write(lut,320)ll,nz,ceq%phase_varres(lokcs)%sites(ll)
320      format('Sublattice ',i2,' with ',i5,' constituents and ',&
              F12.6,' sites')
!      elseif(phlista(lokph)%sites(ll).eq.one) then
      elseif(ceq%phase_varres(lokcs)%sites(ll).eq.one) then
         write(lut,321)nz
321      format('There are ',i5,' constituents:')
      else
!         write(lut,322)nz,phlista(lokph)%sites(ll)
         write(lut,322)nz,ceq%phase_varres(lokcs)%sites(ll)
322      format('Single lattice with ',i5,' constituents and ',&
              F12.6,' sites')
      endif
      text=' '; ip=1
      allocate(consts(nz))
      allocate(ymol(nz))
      consts=' '
      do jl=1,nz
!         jcons=splista(phlista(lokph)%constitlist(nk+jl))%alphaindex
         consts(jl)=' '
         if(phlista(lokph)%constitlist(nk+jl).gt.0) then
            consts(jl)=splista(phlista(lokph)%constitlist(nk+jl))%symbol
         else
            consts(jl)='*'
         endif
         ymol(jl)=ceq%phase_varres(lokcs)%yfr(nk+jl)
      enddo
      call format_phase_composition(mode,nz,consts,ymol,lut)
      deallocate(consts)
      deallocate(ymol)
      if(gx%bmperr.ne.0) goto 1000
      nk=nk+nz
   enddo sublatloop
1000 continue
   return
 end subroutine list_phase_results

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine format_phase_composition(mode,nv,consts,vals,lut)
! list composition/constitution in alphabetical or value order
! entalsiffra 0 mole fraction, 1 mass fraction, 3 mole percent, 4 mass percent
! tiotalsiffra ?
! mode >100 else alphanetical order
! nv is number of components/constitunents (in alphabetical order in consts)
! components/constituents in consts, fractions in vals
   implicit none
   integer nv,mode,lut
   character consts(nv)*(*)
   double precision vals(nv)
!\end{verbatim}
   integer maxl,jl,kp,ncol,nrow2,nvrest,n1,nempty,n3r,n4r
   character names(4)*12
   integer, dimension(:), allocatable :: isort
! 3-13 position name, 12 positions value (1pe12.5), 2 positions separator
! NOTE components can have negative fractions but not constituents
! so leave one blank after component names
! Constituents with names longer than 13 will be written A23456..12345
! with 6 initial characters, two dots and then the 5 last characters
! Max 4 columns with 18 positions(=72) plus 3*2=6 position separator,
! min 3 columns with 24 positions(=72) plus 2*2=4 position separator
!
! max length of names and number of columns
   maxl=0
   do jl=1,nv
      kp=len_trim(consts(jl))
      if(kp.gt.maxl) then
         maxl=kp
      endif
   enddo
   if(maxl.le.4) then
! use 4 columns if names are short
      ncol=4
   else
      ncol=3
   endif
! number of rows is needed to have valuses in columns decending like:
!  FE  0.75 SI 0.05 Ti 0.02 C 0.01
!  CR  0.20 Mn 0.04 V  0.01
!-----------------------------------
   nrow2=(nv+ncol-1)/ncol
! always use isort for the order, if alphabetical isort(i)=i
   allocate(isort(nv+4))
   if(mode.ge.100) then
! value order if mode >100, sort vals and use isort to find component name
      call sortrdd(vals,nv,isort)
      if(buperr.ne.0) then
         write(*,*)'Error sorting fractions',buperr
         gx%bmperr=buperr; goto 1000
      endif
   else
! if alphabetical order just set isort(i)=i, same index as for vals
      do jl=1,nv
         isort(jl)=jl
      enddo
   endif
! list constituents in the order of isort
   if(ncol.eq.4) then
! All names max 4 characters, 4 columns: 1 + 4+1+13+2 +20 +20 +18 =  79
      nvrest=nv
      n1=1
! number of empty colums in last row is 4*nrow2-nv
      nempty=4*nrow2-nv
! 3rd and 4th column may start from one or two indices less
      n3r=2*nrow2
      n4r=3*nrow2
      if(nempty.eq.3) then
         n3r=n3r-1
         n4r=n4r-2
      elseif(nempty.eq.2) then
         n4r=n4r-1
      endif
100   continue
! this can be quite complicated as last row may be partially empty as 
      if(nvrest.ge.4) then
         names(1)=consts(isort(n1))
         names(2)=consts(isort(n1+nrow2))
         names(3)=consts(isort(n1+n3r))
! 4th column may be empty after first row
         if(n1+n4r.le.nv) then
            names(4)=consts(isort(n1+n4r))
            write(lut,110)names(1)(1:4),vals(n1),&
                 names(2)(1:4),vals(n1+nrow2),names(3)(1:4),vals(n1+n3r),&
                 names(4)(1:4),vals(n1+n4r)
110         format(1x,a,1x,1pe13.5,3(2x,a,1x,1pe13.5))
            nvrest=nvrest-4
         else
            write(lut,110)names(1)(1:4),vals(n1),&
                 names(2)(1:4),vals(n1+nrow2),names(3)(1:4),vals(n1+n3r)
            nvrest=nvrest-3
         endif
         n1=n1+1
      else
! last row can be 1 to 3 columns
         names(1)=consts(isort(n1))
         if(nvrest.gt.1) then
            names(2)=consts(isort(n1+nrow2))
            if(nvrest.gt.2) then
               names(3)=consts(isort(n1+n3r))
               write(lut,110)names(1)(1:4),vals(n1),&
                    names(2)(1:4),vals(n1+nrow2),names(3)(1:4),vals(n1+n3r)
            else
               write(lut,110)names(1)(1:4),vals(n1),&
                    names(2)(1:4),vals(n1+nrow2)
            endif
         else
            write(lut,110)names(1)(1:4),vals(n1)
         endif
         nvrest=0
      endif
      if(nvrest.gt.0) goto 100
   else
! All listed names have max 13 characters, longer names are truncated
      nvrest=nv
      n1=1
! number of empty columns in last row
      nempty=3*nrow2-nv
! 3rd column may start from an indices less
      n3r=2*nrow2
      if(nempty.eq.2) then
         n3r=n3r-1
      endif
200   continue
      if(nvrest.ge.3) then
         names(1)=consts(isort(n1))
         names(2)=consts(isort(n1+nrow2))
         if(n1+2*nrow2.le.nv) then
            names(3)=consts(isort(n1+n3r))
            write(lut,210)names(1),vals(n1),names(2),vals(n1+nrow2),&
                 names(3),vals(n1+n3r)
210         format(1x,a,1pe12.5,2(2x,a,1pe12.5))
            nvrest=nvrest-3
         else
            write(lut,210)names(1),vals(n1),names(2),vals(n1+nrow2)
            nvrest=nvrest-2
         endif
         n1=n1+1
      else
! last row can be 1 or 2 columns
         names(1)=consts(isort(n1))
         if(nvrest.gt.1) then
            names(2)=consts(isort(n1+nrow2))
            write(lut,210)names(1),vals(n1),names(2),vals(n1+nrow2)
         else
            write(lut,210)names(1),vals(n1)
         endif
         nvrest=0
      endif
      if(nvrest.gt.0) goto 200
   endif
!
1000 continue
   return
 end subroutine format_phase_composition

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_many_formats(ftyp,unit)
! lists all data in different formats
! unfinished
   implicit none
   integer unit,ftyp
!\end{verbatim}
   integer iph,ipos
   character text*64, text2*2000
   select case(ftyp) 
   case default
      write(kou,*)'No such format'
!----------------------------------------------------------
   case(1) ! ftyp=1 SCREEN format
      call list_all_elements(kou)
      if(gx%bmperr.ne.0) goto 1000
      call list_all_species(kou)
      if(gx%bmperr.ne.0) goto 1000
      call list_all_funs(kou)
      if(gx%bmperr.ne.0) goto 1000
      do iph=1,noph()
         call list_phase_data(iph,kou)
         if(gx%bmperr.ne.0) goto 1000
      enddo
! list reference phase last
      iph=0
      call list_phase_data(0,kou)
! finally list data references
      write(kou,*)
      call list_bibliography(kou)
!--------------------------------------------------------------
   case(2) ! ftyp=2 TDB format
      call list_all_elements2(kou)
      write(kou,*)
      do iph=1, nosp()
         ipos=1
         call list_species_data2(text,ipos,iph)
         write(kou,110)text
110      format('SPECIES ',A,' !')     
      end do
      write(kou,*)
      do iph=1, notpf()! freetpfun-1
         text2='FUNCTION '
         call list_tpfun(iph,0,text2(10:))
!         write(kou,120)text2
120      format(A,' !')
         ipos=len_trim(text2)
         text2(ipos+1:)=' !'
         call  wrice2(kou,0,8,78,1,text2)
      end do
      write(kou,130)
130   format(/'TYPE_DEFINITION % SEQ !'/ &
          ' DEFINE_SYSTEM_DEFAULT ELEMENT 2 !'/ &
          'DEFAULT_COMMAND DEF_SYS_ELEMENT  VA /- !'/)
      do iph=1, noph()
         call list_phase_data2(iph,kou)
      end do
      write(kou,140)
140   format(/' LIST_OF_REFERENCES'/ ' NUMBER  SOURCE')
      call list_bibliography(kou)
!--------------------------------------------------------------
   case(3) ! ftyp=3 MACRO format
      write(kou,*)'Not implemented yet'
!--------------------------------------------------------------
   case(4) ! ftyp=2 LATEX format
      write(kou,*)'Not implemented yet'
   end select
!--------------------------------------------------------------
1000 continue
   return
 end subroutine list_many_formats

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_phase_model(iph,ics,lut,ceq)
! list model (no parameters) for a phase on lut
   implicit none
   integer iph,ics,lut
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   character phname*24,l78*78
!   integer, dimension(maxsubl) :: endm,ilist
   integer lokcs,knr,kmr,ll,ip,lokph
   TYPE(gtp_fraction_set) :: disfra
   type(gtp_phase_add), pointer :: addrec
   double precision rl
! if ics=0 list fractions for all composition sets
   lokph=phases(iph)
! name, model name
! sublattices, status,
! additions
! sites, constituents and fractions in each disordered constituents
! number of disordered sublattices
! sites, constituents and fractions in each disordered constituents
   if(ics.lt.0 .or. ics.gt.phlista(lokph)%noofcs) then
      write(*,*)'No subch composition set'
      gx%bmperr=7777; goto 1000
   elseif(ics.eq.0) then
      ics=1
   endif
   lokcs=phlista(lokph)%linktocs(ics)
   call get_phase_name(iph,ics,phname)
   write(lut,110)phname,phlista(lokph)%models(1:40),&
        phlista(lokph)%noofsubl,phlista(lokph)%status1,&
        ceq%phase_varres(lokcs)%status2
110 format(a,', model: ',a/'Number of sublattices: ',i2,&
        ', status: ',z8,1x,z8,5x)
   addrec=>phlista(lokph)%additions
   lastadd: do while(associated(addrec))
      call list_addition(lut,lokph,addrec)
      addrec=>addrec%nextadd
   enddo lastadd
! return here if more composition sets
200 continue
   rl=zero
   knr=0
   kmr=0
! return here for each sublattice
   do ll=1,phlista(lokph)%noofsubl
      rl=rl+one
      kmr=kmr+phlista(lokph)%nooffr(ll)
      l78='Subl. '; ip=7
      call wrinum(l78,ip,2,0,rl)
      l78(ip:)=', sites: '; ip=ip+9
!      call wrinum(l78,ip,6,0,phlista(lokph)%sites(ll))
      call wrinum(l78,ip,6,0,ceq%phase_varres(lokcs)%sites(ll))
      l78(ip:)=', const.: '; ip=ip+10
! return here for each new constituent in this sublattice
320    continue
      knr=knr+1
      if(phlista(lokph)%constitlist(knr).gt.0) then
         l78(ip:)=splista(phlista(lokph)%constitlist(knr))%symbol
      else
         l78(ip:)='*'
      endif
      ip=len_trim(l78)+2
      l78(ip-1:ip-1)='='
! The fractions for normal sublattice done by list result or list phase-const
      call wrinum(l78,ip,6,0,ceq%phase_varres(lokcs)%yfr(knr))
      l78(ip:ip+1)=', '
      ip=ip+2
      if(ip.gt.60) then
         write(lut,330)l78(1:ip-3)
330       format(a)
         l78=' '
         ip=4
      endif
      if(knr.lt.kmr) goto 320
      if(ip.gt.4) write(lut,330)l78(1:ip-3)
   enddo
   if(btest(phlista(lokph)%status1,PHMFS)) then
! the phase has disordered fractions
! ?? does the = here make a copy?  I just want a pointer ...
      disfra=ceq%phase_varres(lokcs)%disfra
      lokcs=disfra%varreslink
      if(disfra%ndd.eq.1) then
         write(lut,410)disfra%latd
410      format('Disordred fractions adding all fractions from all ',&
              i2,' sublattices together')
      else
         write(lut,420)disfra%latd
420      format('Disordred fractions adding fractions from first ',i2,&
              ' sublattices together'/&
              ' in the first disordered sublattice',&
              ' and the remaining fractions in the second.')
      endif
! write the disordered constituents and fractions
      ll=0
      rl=zero
      knr=0
      kmr=0
! return here for second sublattice (if any)
430   continue
      ll=ll+1
      rl=rl+one
      kmr=kmr+disfra%nooffr(ll)
      l78='Subl. '; ip=7
      call wrinum(l78,ip,2,0,rl)
      l78(ip:)=', sites: '; ip=ip+9
      call wrinum(l78,ip,6,0,disfra%dsites(ll))
      l78(ip:)=', const.: '; ip=ip+10
! return here for each new constituent in this sublattice
440   continue
      knr=knr+1
      l78(ip:)=splista(disfra%splink(knr))%symbol
! list fractions in disordered sublattice as this is the only place for that
      ip=len_trim(l78)+2
      l78(ip-1:ip-1)='='
      call wrinum(l78,ip,6,0,ceq%phase_varres(lokcs)%yfr(knr))
      l78(ip:)=','
      ip=ip+2
      if(ip.gt.60) then
         write(lut,330)l78(1:ip-3)
         l78=' '
         ip=4
      endif
      if(knr.lt.kmr) goto 440
      if(ip.gt.4) write(lut,330)l78(1:ip-3)
      if(ll.lt.disfra%ndd) goto 430
   endif
1000 continue
   return
 end subroutine list_phase_model

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_phase_data(iph,lut)
! list parameter data for a phase on unit lut
   implicit none
   integer iph,lut
!\end{verbatim} %+
   integer typty,parlist,typspec,lokph,nsl,nk,ip,ll,jnr,ics,lokcs
   integer nint,ideg,ij,kk,iel,ncsum,kkx,kkk,jdeg,iqnext,iqhigh,lqq,nz,ik
   integer intpq,linkcon
   character text*1024,phname*24,prop*32,funexpr*512
   character special*8
   integer, dimension(2,3) :: lint
   integer, dimension(maxsubl) :: endm,ilist
   logical subref,noelin1
   type(gtp_fraction_set), pointer :: disfrap
! a smart way to have an array of pointers
   TYPE intrecarray 
      type(gtp_interaction), pointer :: p1
   end TYPE intrecarray
   type(intrecarray), dimension(20) :: intrecstack
   type(gtp_property), pointer :: proprec
   type(gtp_interaction), pointer :: intrec
   type(gtp_endmember), pointer :: endmemrec
   TYPE(gtp_fraction_set) :: disfra
   TYPE(gtp_phase_add), pointer :: addrec
!
   if(iph.lt.0 .or. iph.gt.noofph) then
      gx%bmperr=4050; goto 1000
   elseif(noofel.eq.0) then
! this needed as there is a reference phase with iph=0 when there are elements
      goto 1000
   endif
!   write(*,*)'lpd 1:',iph,phases(iph)
   if(iph.gt.0) then
      lokph=phases(iph)
   else
      lokph=0
   endif
   ics=1
   phname=phlista(lokph)%name
   nsl=phlista(lokph)%noofsubl
   special=' '
! indicate some status bit specially
   if(btest(phlista(lokph)%status1,PHFORD)) special(1:1)='F'
   if(btest(phlista(lokph)%status1,PHBORD)) special(1:1)='B'
   if(btest(phlista(lokph)%status1,PHSORD)) special(1:1)='S'
   if(btest(phlista(lokph)%status1,PHIONLIQ)) special(1:1)='I'
   if(btest(phlista(lokph)%status1,PHMFS)) special(2:2)='D'
! This subroutine is independent of current equilibrium, use firsteq
!   write(lut,10)phname,phlista(lokph)%status1,special,&
!        nsl,(phlista(lokph)%sites(ll),ll=1,nsl)
   lokcs=phlista(lokph)%linktocs(ics)
   write(lut,10)phname,phlista(lokph)%status1,special,&
        nsl,(firsteq%phase_varres(lokcs)%sites(ll),ll=1,nsl)
10  format(/'Phase: ',A,', Status: ',Z8,2x,a/'  Subl:',I3,10(1x,F7.3))
   nk=0
   text='Constituents: '
   ip=15
   sublatloop: do ll=1,nsl
      constloop: do ik=1,phlista(lokph)%nooffr(ll)
         nk=nk+1
         jnr=phlista(lokph)%constitlist(nk)
         if(jnr.gt.0) then
            text(ip:)=splista(jnr)%symbol
         else
            text(ip:)='*'
         endif
         ip=len_trim(text)+1
!         text(ip:ip)=','
         text(ip:ip)=' '
         ip=ip+1
      enddo constloop
      text(ip-1:ip)=':  '
      ip=ip+1
   enddo sublatloop
   call wrice2(lut,2,4,78,-1,text)
!    write(lut,17)text(1:ip)
!17  format(A)
! additions
   addrec=>phlista(lokph)%additions
   lastadd: do while(associated(addrec))
      call list_addition(lut,lokph,addrec)
      addrec=>addrec%nextadd
   enddo lastadd
60 continue
! parameters for end members using site fractions
   if(btest(phlista(lokph)%status1,PHMFS)) then
      subref=.FALSE.
   else
      subref=.TRUE.
   endif
   parlist=1
!--------------------------------------------------
! return here to list disordered parameters
100 continue
! parlist changed below for disordered fraction set
   if(parlist.eq.1) then
      endmemrec=>phlista(lokph)%ordered
   else
      if(ocv()) write(*,*)'Listing disordred parameters ',nsl
      endmemrec=>phlista(lokph)%disordered
      disfrap=>firsteq%phase_varres(lokcs)%disfra
   endif
   endmemberlist: do while(associated(endmemrec))
      do ll=1,nsl
!         ilist(ll)=emlista(lokem)%fraclinks(ll,1)
         ilist(ll)=endmemrec%fraclinks(ll,1)
         if(ilist(ll).gt.0) then
            if(parlist.eq.2) then
! what is disfra here??!!
               endm(ll)=disfra%splink(ilist(ll))
            else
               endm(ll)=phlista(lokph)%constitlist(ilist(ll))
            endif
         else
! wildcard, write '*'
            endm(ll)=-99
         endif
      enddo
      nint=0
      ideg=0
      call encode_constarr(text,nsl,endm,nint,lint,ideg)
      if(gx%bmperr.ne.0) goto 1000
      proprec=>endmemrec%propointer
      ptyloop: do while(associated(proprec))
         ij=proprec%proptype
         if(ij.ge.100) then
            typty=ij/100
            typspec=mod(ij,100)
         else
            typty=ij
         endif
         if(typty.gt.0 .and. typty.le.ndefprop) then
            prop=propid(typty)%symbol
            if(parlist.eq.2) then
! disordered endmember parameter
               kk=len_trim(prop)+1
               prop(kk:kk)='D'
            endif
            if(btest(propid(typty)%status,IDELSUFFIX)) then
! property like ZZ&<element>(phase,constituent array)
! the element index should be in typsepc
               iel=typspec
               if(iel.ge.0 .and. iel.le.noofel) then
!                  prop=propid(typty)%symbol
                  prop=prop(1:len_trim(prop))//'&'&
                       //ellista(elements(iel))%symbol
               else
                  gx%bmperr=4082; goto 1000
               endif
            elseif(btest(propid(typty)%status,IDCONSUFFIX)) then
! property like mobility, MQ&<constituent#sublat>(phase,constituent array)
! the suffix is a constituent
               iel=typspec
               if(iel.gt.0 .and. iel.le.phlista(lokph)%tnooffr) then
                  if(parlist.eq.2) then
! we must consider parlist, take disordered constituent list
! we have no current equilibrium record but can use firsteq!!
!                     lokcs=phlista(lokph)%linktocs(1)
!                     write(*,*)'25E: endmember typspec 1: ',iel
                     linkcon=disfrap%splink(iel)
!                     write(*,*)'25E: endmember typspec 2: ',linkcon
                     ll=1
                     if(linkcon.gt.disfrap%nooffr(1)) ll=2
                     prop=prop(1:len_trim(prop))//'&'&
                          //splista(linkcon)%symbol
                     goto 120
                  else
                     linkcon=phlista(lokph)%constitlist(iel)
                     if(linkcon.le.0) then
                        write(*,*)'Illegal use of wildcard 1'
                        gx%bmperr=7777; goto 1000
                     endif
                     prop=prop(1:len_trim(prop))//'&'&
                          //splista(linkcon)%symbol
! also add the sublattice number ...
                     ncsum=0
                     do ll=1,phlista(lokph)%noofsubl
                        ncsum=ncsum+phlista(lokph)%nooffr(ll)
                        if(iel.le.ncsum) goto 120
                     enddo
                  endif
! error if sublattice not found
                  write(kou,*)'Error in constituent depended parameter id'
                  gx%bmperr=7777; goto 1000
! jump here to append sublattice
120               continue
!                  write(*,*)'property 1: ',prop(1:10),ll
                  prop=prop(1:len_trim(prop))//'#'//char(ll+ichar('0'))
               else
                  write(kou,*)'lpd 7B: ',iel,typty
                  gx%bmperr=4082; goto 1000
               endif
            endif
         else
! unknown property ...
            write(*,*)'unknown property type xx: ',ij,typty,typspec
            prop='ZZ'
         endif
! if disordered fraction set add D, already done above
!         if(parlist.eq.2) then
!            prop=prop(1:len_trim(prop))//'D'
!         endif
! note changes here must be repeated for interaction parameters below
         write(funexpr,200)prop(1:len_trim(prop)),&
              phname(1:len_trim(phname)),text(1:len_trim(text))
200      format(A,'(',A,',',A,') ')
         ip=len_trim(funexpr)+1
! subtract reference states
         if(subref .and. typty.eq.1) then
            call subrefstates(funexpr,ip,lokph,parlist,endm,noelin1)
            if(noelin1) then
! this can happen for ionic liquids with just neutrals in sublattice 2
! replace the constituent in sublattice 1 with "*" !!!
!               write(*,*)'before: ',funexpr(1:ip)
               kk=index(funexpr,',')
               ik=index(funexpr,':')
               funexpr(kk+1:)='*'//funexpr(ik:)
               ip=len_trim(funexpr)+2
!               write(*,*)'after:  ',funexpr(1:ip)
            endif
         endif
! this writes the expression
         call list_tpfun(proprec%degreelink(0),1,funexpr(ip:))
         ip=len_trim(funexpr)
         funexpr(ip+1:)=' '//proprec%reference
         ip=len_trim(funexpr)
! nice output over several lines if needed with indentation 12 spaces
         call wrice2(lut,2,12,78,1,funexpr(1:ip))
         proprec=>proprec%nextpr
      enddo ptyloop
      if(endmemrec%noofpermut.gt.1) then
         intpq=0
         if(associated(endmemrec%intpointer)) then
            intpq=endmemrec%intpointer%antalint
         endif
!         write(kou,207)endmemrec%antalem,endmemrec%noofpermut,intpq
207      format('@$ Endmember, permutations, interaction: ',3i5)
      endif
      endmemrec=>endmemrec%nextem
   enddo endmemberlist
!-----------------------------------------------------------------------
! parameters for interactions using site fractions
   if(parlist.eq.1) then
      endmemrec=>phlista(lokph)%ordered
   else
      endmemrec=>phlista(lokph)%disordered
   endif
   intlist1: do while(associated(endmemrec))
      intrec=>endmemrec%intpointer
      if(associated(intrec)) then
!         write(*,*)'intlist 1B: ',intrec%status
         do ll=1,nsl
            kkx=endmemrec%fraclinks(ll,1)
            if(kkx.eq.-99) then
! wildcard
               endm(ll)=-99
            elseif(parlist.eq.2) then
               endm(ll)=disfra%splink(kkx)
            else
               endm(ll)=phlista(lokph)%constitlist(kkx)
            endif
         enddo
      endif
      nint=0
      intlist2: do while(associated(intrec))
         nint=nint+1
         intrecstack(nint)%p1=>intrec
         lint(1,nint)=intrec%sublattice(1)
         kkk=intrec%fraclink(1)
         if(parlist.eq.2) then
            lint(2,nint)=disfra%splink(kkk)
         else
            lint(2,nint)=phlista(lokph)%constitlist(kkk)
         endif
         proprec=>intrec%propointer
         ptyloop2: do while(associated(proprec))
!            typty=proprec%proptype
            ij=proprec%proptype
            if(ij.ge.100) then
               typty=ij/100
               typspec=mod(ij,100)
            else
               typty=ij
            endif
!            typspec=proprec%proptype
!            if(typspec.gt.100) then
!               typty=typspec/100
!               typspec=mod(typty,100)
!            else
!               typty=typspec
!            endif
            if(typty.gt.0 .and. typty.le.ndefprop) then
               prop=propid(typty)%symbol
               if(parlist.eq.2) then
! disordered interaction parameter
                  kk=len_trim(prop)+1
                  prop(kk:kk)='D'
               endif
               if(btest(propid(typty)%status,IDELSUFFIX)) then
! property like ZZ&<element>(phase,constituent array)
! the element index should be in typsepc
                  iel=typspec
                  if(iel.ge.0 .and. iel.le.noofel) then
                     prop=prop(1:len_trim(prop))//'&'&
                          //ellista(elements(iel))%symbol
                  else
!                          write(*,*)'lpd 7: ',iel,typty
                     gx%bmperr=4082; goto 1000
                  endif
               elseif(btest(propid(typty)%status,IDCONSUFFIX)) then
! property like mobility MQ&<constiutent#sublatt>(phase,constituent array)
! the suffix is a constituent
                  iel=typspec
                  if(iel.gt.0 .and. iel.le.phlista(lokph)%tnooffr) then
                     if(parlist.eq.2) then
! we must consider parlist, take disordered constituent list
! we have no current equilibrium record but can use firsteq!!
!                        write(*,*)'25E: typspec: 3 ',typty,iel,prop(1:10)
                        linkcon=disfrap%splink(iel)
!                        write(*,*)'25E: typspec: 4 ',typty,linkcon,prop(1:10)
                        ll=1
                        if(iel.gt.disfrap%nooffr(1)) ll=2
                        prop=prop(1:len_trim(prop))//'&'&
                             //splista(linkcon)%symbol
                        goto 220
                     else
                        linkcon=phlista(lokph)%constitlist(iel)
                        if(linkcon.le.0) then
                           write(*,*)'Illegal use of wildcard 2'
                           gx%bmperr=7777; goto 1000
                        endif
                        prop=prop(1:len_trim(prop))//'&'&
                             //splista(linkcon)%symbol
! also add the sublattice number ...
                        ncsum=0
                        do ll=1,phlista(lokph)%noofsubl
                           ncsum=ncsum+phlista(lokph)%nooffr(ll)
                           if(iel.le.ncsum) goto 220
                        enddo
                     endif
! there cannot be any errors here ....
                     write(*,*)'Never never error 2'
                     gx%bmperr=7777; goto 1000
220                  continue
!                     write(*,*)'property 2: ',prop(1:10),ll
                     prop=prop(1:len_trim(prop))//'#'//char(ll+ichar('0'))
                  else
!                          write(*,*)'lpd 7: ',iel,typty
                     gx%bmperr=4082; goto 1000
                  endif
               endif
            else
! unknown property ...
               write(*,*)'unknown property type yy: ',typty
               prop='ZZ'
            endif
! if disordered fraction set add D, already set above ??!!
!         if(parlist.eq.2) then
!            prop=prop(1:len_trim(prop))//'D'
!         endif
! note changes here must be repeated for endmember parameters above
            do jdeg=0,proprec%degree
               call encode_constarr(text,nsl,endm,nint,lint,jdeg)
               write(funexpr,300)prop(1:len_trim(prop)), &
                    phname(1:len_trim(phname)),text(1:len_trim(text))
300            format(A,'(',A,',',A,') ')
               ip=len_trim(funexpr)+1
               call list_tpfun(proprec%degreelink(jdeg),1,funexpr(ip:))
               ip=len_trim(funexpr)
               funexpr(ip+1:)=' '//proprec%reference
               ip=len_trim(funexpr)
               call wrice2(lut,4,12,78,1,funexpr(1:ip))
            enddo
            proprec=>proprec%nextpr
         enddo ptyloop2
! list temporarily the number of permutations
         if(intrec%noofip(1).gt.1 .or. intrec%noofip(2).gt.1) then
            if(nint.eq.1) then
               nz=intrec%noofip(2)
            else
               nz=size(intrec%sublattice)
               lqq=intrec%noofip(size(intrec%noofip))
               if(lqq.ne.nz) then
                  write(*,*)'Not same: ',intrec%antalint,nz,lqq
               endif
!               write(*,301)nz,intrec%noofip
301            format('noofip: ',10i3)
!               nz=intrec%noofip(intrec%noofip(1)+2)
            endif
            iqnext=0
            iqhigh=0
            if(associated(intrec%highlink)) then
               iqhigh=intrec%highlink%antalint
            endif
            if(associated(intrec%nextlink)) then
               iqnext=intrec%nextlink%antalint
            endif
            write(*,302)intrec%antalint,nz,nint,iqhigh,iqnext
302         format('@$ Interaction, permutations, level, high, next: ',5i5)
         endif
         intrec=>intrec%highlink
         empty: do while(.not.associated(intrec))
            if(nint.gt.0) then
! restore pointers in same clumsy way
               intrec=>intrecstack(nint)%p1
               intrec=>intrec%nextlink
!               write(*,*)'poping a pointer from intrecstack',ninit
               nint=nint-1
            else
               exit intlist2
            endif
         enddo empty
      enddo intlist2
      endmemrec=>endmemrec%nextem
   enddo intlist1
! check if there are other fraction lists
!   parlist=parlist+1, hm parlist can only be 1 or 2
!   write(*,*)'checking for disordered parameters'
   if(parlist.eq.1 .and. associated(phlista(lokph)%disordered)) then
      subref=.TRUE.
!      lokcs=phlista(lokph)%cslink
      lokcs=phlista(lokph)%linktocs(ics)
! does this make a copy?  Maybe it should be a pointer
      disfra=firsteq%phase_varres(lokcs)%disfra
      write(lut,810)disfra%fsites
810    format('Disordered fraction parameters: ',F10.4,2x,20('-'))
      nsl=disfra%ndd
      parlist=2
      if(ocv()) write(*,*)'Jump back to list disordered',nsl,parlist
      goto 100
   endif
1000 continue
   return
 END subroutine list_phase_data

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim} %-
 subroutine list_phase_data2(iph,lut)
! list parameter data for a phase on unit lut in TDB format
   implicit none
   integer iph,lut
!\end{verbatim}
   integer typty,parlist,typspec,lokph,nsl,nk,ip,ll,jnr,ics,lokcs
   integer nint,ideg,ij,kk,iel,ncsum,kkx,kkk,jdeg,iqnext,iqhigh,lqq,nz,ik
   integer intpq,linkcon
   character text*1024,phname*24,prop*32,funexpr*512
   character special*8
   integer, dimension(2,3) :: lint
   integer, dimension(maxsubl) :: endm,ilist
   logical subref,noelin1
   type(gtp_fraction_set), pointer :: disfrap
! a smart way to have an array of pointers
   TYPE intrecarray 
      type(gtp_interaction), pointer :: p1
   end TYPE intrecarray
   type(intrecarray), dimension(20) :: intrecstack
   type(gtp_property), pointer :: proprec
   type(gtp_interaction), pointer :: intrec
   type(gtp_endmember), pointer :: endmemrec
   TYPE(gtp_fraction_set) :: disfra
   TYPE(gtp_phase_add), pointer :: addrec
!
   if(iph.lt.0 .or. iph.gt.noofph) then
      gx%bmperr=4050; goto 1000
   elseif(noofel.eq.0) then
! this needed as there is a reference phase with iph=0 when there are elements
      goto 1000
   endif
!   write(*,*)'lpd 1:',iph,phases(iph)
   if(iph.gt.0) then
      lokph=phases(iph)
   else
      lokph=0
   endif
   ics=1
   phname=phlista(lokph)%name
   nsl=phlista(lokph)%noofsubl
   special=' '
! indicate some status bit specially
   if(btest(phlista(lokph)%status1,PHFORD)) special(1:1)='F'
   if(btest(phlista(lokph)%status1,PHBORD)) special(1:1)='B'
   if(btest(phlista(lokph)%status1,PHSORD)) special(1:1)='S'
   if(btest(phlista(lokph)%status1,PHIONLIQ)) special(1:1)='I'
   if(btest(phlista(lokph)%status1,PHMFS)) special(2:2)='D'
! This subroutine is independent of current equilibrium, use firsteq
!   write(lut,10)phname,phlista(lokph)%status1,special,&
!        nsl,(phlista(lokph)%sites(ll),ll=1,nsl)
   lokcs=phlista(lokph)%linktocs(ics)
   write(lut,10)phname,&
        nsl,(firsteq%phase_varres(lokcs)%sites(ll),ll=1,nsl)
10  format(/'PHASE ',A,' %',I3,10(1x,F7.3))
   nk=0
   text='   CONSTITUENT '//phname//' :'
   ip=len_trim(text)+1
   sublatloop: do ll=1,nsl
      constloop: do ik=1,phlista(lokph)%nooffr(ll)
         nk=nk+1
         jnr=phlista(lokph)%constitlist(nk)
         if(jnr.gt.0) then
            text(ip:)=splista(jnr)%symbol
         else
            text(ip:)='*'
         endif
         ip=len_trim(text)+1
!         text(ip:ip)=','
         text(ip:ip)=' '
         ip=ip+1
      enddo constloop
      text(ip-1:ip)=':  '
      ip=ip+1
   enddo sublatloop
   text(ip-2:)=':!'
   call wrice2(lut,2,4,78,-1,text)
!    write(lut,17)text(1:ip)
!17  format(A)
! additions
   addrec=>phlista(lokph)%additions
   lastadd: do while(associated(addrec))
      call list_addition(lut,lokph,addrec)
      addrec=>addrec%nextadd
   enddo lastadd
60 continue
! parameters for end members using site fractions
   if(btest(phlista(lokph)%status1,PHMFS)) then
      subref=.FALSE.
   else
      subref=.TRUE.
   endif
   parlist=1
!--------------------------------------------------
! return here to list disordered parameters
100 continue
! parlist changed below for disordered fraction set
   if(parlist.eq.1) then
      endmemrec=>phlista(lokph)%ordered
   else
      if(ocv()) write(*,*)'Listing disordred parameters ',nsl
      endmemrec=>phlista(lokph)%disordered
      disfrap=>firsteq%phase_varres(lokcs)%disfra
   endif
   endmemberlist: do while(associated(endmemrec))
      do ll=1,nsl
!         ilist(ll)=emlista(lokem)%fraclinks(ll,1)
         ilist(ll)=endmemrec%fraclinks(ll,1)
         if(ilist(ll).gt.0) then
            if(parlist.eq.2) then
! what is disfra here??!!
               endm(ll)=disfra%splink(ilist(ll))
            else
               endm(ll)=phlista(lokph)%constitlist(ilist(ll))
            endif
         else
! wildcard, write '*'
            endm(ll)=-99
         endif
      enddo
      nint=0
      ideg=0
      call encode_constarr(text,nsl,endm,nint,lint,ideg)
      if(gx%bmperr.ne.0) goto 1000
      proprec=>endmemrec%propointer
      ptyloop: do while(associated(proprec))
         ij=proprec%proptype
         if(ij.ge.100) then
            typty=ij/100
            typspec=mod(ij,100)
         else
            typty=ij
         endif
         if(typty.gt.0 .and. typty.le.ndefprop) then
            prop=propid(typty)%symbol
            if(parlist.eq.2) then
! disordered endmember parameter
               kk=len_trim(prop)+1
               prop(kk:kk)='D'
            endif
            if(btest(propid(typty)%status,IDELSUFFIX)) then
! property like ZZ&<element>(phase,constituent array)
! the element index should be in typsepc
               iel=typspec
               if(iel.ge.0 .and. iel.le.noofel) then
!                  prop=propid(typty)%symbol
                  prop=prop(1:len_trim(prop))//'&'&
                       //ellista(elements(iel))%symbol
               else
                  gx%bmperr=4082; goto 1000
               endif
            elseif(btest(propid(typty)%status,IDCONSUFFIX)) then
! property like mobility, MQ&<constituent#sublat>(phase,constituent array)
! the suffix is a constituent
               iel=typspec
               if(iel.gt.0 .and. iel.le.phlista(lokph)%tnooffr) then
                  if(parlist.eq.2) then
! we must consider parlist, take disordered constituent list
! we have no current equilibrium record but can use firsteq!!
!                     lokcs=phlista(lokph)%linktocs(1)
!                     write(*,*)'25E: endmember typspec 1: ',iel
                     linkcon=disfrap%splink(iel)
!                     write(*,*)'25E: endmember typspec 2: ',linkcon
                     ll=1
                     if(linkcon.gt.disfrap%nooffr(1)) ll=2
                     prop=prop(1:len_trim(prop))//'&'&
                          //splista(linkcon)%symbol
                     goto 120
                  else
                     linkcon=phlista(lokph)%constitlist(iel)
                     if(linkcon.le.0) then
                        write(*,*)'Illegal use of wildcard 1'
                        gx%bmperr=7777; goto 1000
                     endif
                     prop=prop(1:len_trim(prop))//'&'&
                          //splista(linkcon)%symbol
! also add the sublattice number ...
                     ncsum=0
                     do ll=1,phlista(lokph)%noofsubl
                        ncsum=ncsum+phlista(lokph)%nooffr(ll)
                        if(iel.le.ncsum) goto 120
                     enddo
                  endif
! error if sublattice not found
                  write(kou,*)'Error in constituent depended parameter id'
                  gx%bmperr=7777; goto 1000
! jump here to append sublattice
120               continue
!                  write(*,*)'property 1: ',prop(1:10),ll
                  prop=prop(1:len_trim(prop))//'#'//char(ll+ichar('0'))
               else
                  write(kou,*)'lpd 7B: ',iel,typty
                  gx%bmperr=4082; goto 1000
               endif
            endif
         else
! unknown property ...
            write(*,*)'unknown property type xx: ',ij,typty,typspec
            prop='ZZ'
         endif
! if disordered fraction set add D, already done above
!         if(parlist.eq.2) then
!            prop=prop(1:len_trim(prop))//'D'
!         endif
! note changes here must be repeated for interaction parameters below
         write(funexpr,200)prop(1:len_trim(prop)),&
              phname(1:len_trim(phname)),text(1:len_trim(text))
200      format('   PARAMETER ',A,'(',A,',',A,') ')
         ip=len_trim(funexpr)+1
! subtract reference states
         if(subref .and. typty.eq.1) then
            call subrefstates(funexpr,ip,lokph,parlist,endm,noelin1)
            if(noelin1) then
! this can happen for ionic liquids with just neutrals in sublattice 2
! replace the constituent in sublattice 1 with "*" !!!
!               write(*,*)'before: ',funexpr(1:ip)
               kk=index(funexpr,',')
               ik=index(funexpr,':')
               funexpr(kk+1:)='*'//funexpr(ik:)
               ip=len_trim(funexpr)+2
!               write(*,*)'after:  ',funexpr(1:ip)
            endif
         endif
! this writes the expression
         call list_tpfun(proprec%degreelink(0),1,funexpr(ip:))
         ip=len_trim(funexpr)
         funexpr(ip+1:)=' '//proprec%reference
         ip=len_trim(funexpr)
         funexpr(ip+1:)=' !'
! nice output over several lines if needed with indentation 12 spaces
         call wrice2(lut,2,12,78,1,funexpr(1:ip+2))
         proprec=>proprec%nextpr
      enddo ptyloop
      if(endmemrec%noofpermut.gt.1) then
         intpq=0
         if(associated(endmemrec%intpointer)) then
            intpq=endmemrec%intpointer%antalint
         endif
!         write(kou,207)endmemrec%antalem,endmemrec%noofpermut,intpq
207      format('@$ Endmember, permutations, interaction: ',3i5)
      endif
      endmemrec=>endmemrec%nextem
   enddo endmemberlist
!-----------------------------------------------------------------------
! parameters for interactions using site fractions
   if(parlist.eq.1) then
      endmemrec=>phlista(lokph)%ordered
   else
      endmemrec=>phlista(lokph)%disordered
   endif
   intlist1: do while(associated(endmemrec))
      intrec=>endmemrec%intpointer
      if(associated(intrec)) then
!         write(*,*)'intlist 1B: ',intrec%status
         do ll=1,nsl
            kkx=endmemrec%fraclinks(ll,1)
            if(kkx.eq.-99) then
! wildcard
               endm(ll)=-99
            elseif(parlist.eq.2) then
               endm(ll)=disfra%splink(kkx)
            else
               endm(ll)=phlista(lokph)%constitlist(kkx)
            endif
         enddo
      endif
      nint=0
      intlist2: do while(associated(intrec))
         nint=nint+1
         intrecstack(nint)%p1=>intrec
         lint(1,nint)=intrec%sublattice(1)
         kkk=intrec%fraclink(1)
         if(parlist.eq.2) then
            lint(2,nint)=disfra%splink(kkk)
         else
            lint(2,nint)=phlista(lokph)%constitlist(kkk)
         endif
         proprec=>intrec%propointer
         ptyloop2: do while(associated(proprec))
!            typty=proprec%proptype
            ij=proprec%proptype
            if(ij.ge.100) then
               typty=ij/100
               typspec=mod(ij,100)
            else
               typty=ij
            endif
!            typspec=proprec%proptype
!            if(typspec.gt.100) then
!               typty=typspec/100
!               typspec=mod(typty,100)
!            else
!               typty=typspec
!            endif
            if(typty.gt.0 .and. typty.le.ndefprop) then
               prop=propid(typty)%symbol
               if(parlist.eq.2) then
! disordered interaction parameter
                  kk=len_trim(prop)+1
                  prop(kk:kk)='D'
               endif
               if(btest(propid(typty)%status,IDELSUFFIX)) then
! property like ZZ&<element>(phase,constituent array)
! the element index should be in typsepc
                  iel=typspec
                  if(iel.ge.0 .and. iel.le.noofel) then
                     prop=prop(1:len_trim(prop))//'&'&
                          //ellista(elements(iel))%symbol
                  else
!                          write(*,*)'lpd 7: ',iel,typty
                     gx%bmperr=4082; goto 1000
                  endif
               elseif(btest(propid(typty)%status,IDCONSUFFIX)) then
! property like mobility MQ&<constiutent#sublatt>(phase,constituent array)
! the suffix is a constituent
                  iel=typspec
                  if(iel.gt.0 .and. iel.le.phlista(lokph)%tnooffr) then
                     if(parlist.eq.2) then
! we must consider parlist, take disordered constituent list
! we have no current equilibrium record but can use firsteq!!
!                        write(*,*)'25E: typspec: 3 ',typty,iel,prop(1:10)
                        linkcon=disfrap%splink(iel)
!                        write(*,*)'25E: typspec: 4 ',typty,linkcon,prop(1:10)
                        ll=1
                        if(iel.gt.disfrap%nooffr(1)) ll=2
                        prop=prop(1:len_trim(prop))//'&'&
                             //splista(linkcon)%symbol
                        goto 220
                     else
                        linkcon=phlista(lokph)%constitlist(iel)
                        if(linkcon.le.0) then
                           write(*,*)'Illegal use of wildcard 2'
                           gx%bmperr=7777; goto 1000
                        endif
                        prop=prop(1:len_trim(prop))//'&'&
                             //splista(linkcon)%symbol
! also add the sublattice number ...
                        ncsum=0
                        do ll=1,phlista(lokph)%noofsubl
                           ncsum=ncsum+phlista(lokph)%nooffr(ll)
                           if(iel.le.ncsum) goto 220
                        enddo
                     endif
! there cannot be any errors here ....
                     write(*,*)'Never never error 2'
                     gx%bmperr=7777; goto 1000
220                  continue
!                     write(*,*)'property 2: ',prop(1:10),ll
                     prop=prop(1:len_trim(prop))//'#'//char(ll+ichar('0'))
                  else
!                          write(*,*)'lpd 7: ',iel,typty
                     gx%bmperr=4082; goto 1000
                  endif
               endif
            else
! unknown property ...
               write(*,*)'unknown property type yy: ',typty
               prop='ZZ'
            endif
! if disordered fraction set add D, already set above ??!!
!         if(parlist.eq.2) then
!            prop=prop(1:len_trim(prop))//'D'
!         endif
! note changes here must be repeated for endmember parameters above
            do jdeg=0,proprec%degree
               call encode_constarr(text,nsl,endm,nint,lint,jdeg)
               write(funexpr,300)prop(1:len_trim(prop)), &
                    phname(1:len_trim(phname)),text(1:len_trim(text))
300            format('PARAMETER ',A,'(',A,',',A,') ')
               ip=len_trim(funexpr)+1
               call list_tpfun(proprec%degreelink(jdeg),1,funexpr(ip:))
               ip=len_trim(funexpr)
               funexpr(ip+1:)=' '//proprec%reference
               ip=len_trim(funexpr)
               funexpr(ip+1:)=' !'
               call wrice2(lut,4,12,78,1,funexpr(1:ip+2))
            enddo
            proprec=>proprec%nextpr
         enddo ptyloop2
! list temporarily the number of permutations
         if(intrec%noofip(1).gt.1 .or. intrec%noofip(2).gt.1) then
            if(nint.eq.1) then
               nz=intrec%noofip(2)
            else
               nz=size(intrec%sublattice)
               lqq=intrec%noofip(size(intrec%noofip))
               if(lqq.ne.nz) then
                  write(*,*)'Not same: ',intrec%antalint,nz,lqq
               endif
!               write(*,301)nz,intrec%noofip
301            format('noofip: ',10i3)
!               nz=intrec%noofip(intrec%noofip(1)+2)
            endif
            iqnext=0
            iqhigh=0
            if(associated(intrec%highlink)) then
               iqhigh=intrec%highlink%antalint
            endif
            if(associated(intrec%nextlink)) then
               iqnext=intrec%nextlink%antalint
            endif
            write(*,302)intrec%antalint,nz,nint,iqhigh,iqnext
302         format('@$ Interaction, permutations, level, high, next: ',5i5)
         endif
         intrec=>intrec%highlink
         empty: do while(.not.associated(intrec))
            if(nint.gt.0) then
! restore pointers in same clumsy way
               intrec=>intrecstack(nint)%p1
               intrec=>intrec%nextlink
!               write(*,*)'poping a pointer from intrecstack',ninit
               nint=nint-1
            else
               exit intlist2
            endif
         enddo empty
      enddo intlist2
      endmemrec=>endmemrec%nextem
   enddo intlist1
! check if there are other fraction lists
!   parlist=parlist+1, hm parlist can only be 1 or 2
!   write(*,*)'checking for disordered parameters'
   if(parlist.eq.1 .and. associated(phlista(lokph)%disordered)) then
      write(lut,810)
810    format('Disordered fraction parameters:',20('-'))
      subref=.TRUE.
!      lokcs=phlista(lokph)%cslink
      lokcs=phlista(lokph)%linktocs(ics)
! does this make a copy?  Maybe it should be a pointer
      disfra=firsteq%phase_varres(lokcs)%disfra
      nsl=disfra%ndd
      parlist=2
      if(ocv()) write(*,*)'Jump back to list disordered',nsl,parlist
      goto 100
   endif
1000 continue
   return
 END subroutine list_phase_data2

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine subrefstates(funexpr,jp,lokph,parlist,endm,noelin1)
! list a sum of reference states for a G parameter
! like "-H298(BCC_A2,FE)-3*H298(GRAPITE,C)"
   implicit none
   integer jp,lokph,parlist,endm(*)
   character funexpr*(*)
   logical noelin1
!\end{verbatim}
! special care for ionic liquid as sites varies ...
   character text*80,els*2
   integer element(maxel),lokel
   double precision coef(maxel),xx,pqval(2)
   TYPE(gtp_fraction_set) :: disfra
   integer nsl,lokcs,ie,ll,jsp,nrel,ik,je,more,is,ip
!
   noelin1=.FALSE.
   lokcs=phlista(lokph)%linktocs(1)
   if(btest(phlista(lokph)%status1,PHIONLIQ)) goto 210
   if(parlist.eq.1) then
      nsl=phlista(lokph)%noofsubl
   else
! should disfra be a pointer?? It seems to work like this ....
      disfra=firsteq%phase_varres(lokcs)%disfra
      nsl=disfra%ndd
   endif
   ie=0
   sublat: do ll=1,nsl
      jsp=endm(ll)
      if(jsp.gt.0) then
         nrel=splista(jsp)%noofel
         elem: do ik=1,nrel
            do je=1,ie
               if(splista(jsp)%ellinks(ik).eq.element(je)) then
                  if(parlist.eq.1) then
                     coef(je)=coef(je)+&
                     firsteq%phase_varres(lokcs)%sites(ll)*&
                     splista(jsp)%stoichiometry(ik)
!                     phlista(lokph)%sites(ll)*splista(jsp)%stoichiometry(ik)
                  else
                     coef(je)=coef(je)+&
                     disfra%dsites(ll)*splista(jsp)%stoichiometry(ik)
                  endif
                  goto 200
               endif
            enddo
! new element, increment ie and initiate coef
! ignore the element VA with element index 0
            if(splista(jsp)%ellinks(ik).eq.0) goto 200
            ie=ie+1
            element(ie)=splista(jsp)%ellinks(ik)
            if(parlist.eq.1) then
               coef(ie)=&
                    firsteq%phase_varres(lokcs)%sites(ll)*&
                    splista(jsp)%stoichiometry(ik)
!                    phlista(lokph)%sites(ll)*splista(jsp)%stoichiometry(ik)
            else
               coef(ie)=disfra%dsites(ll)*splista(jsp)%stoichiometry(ik)
            endif
200          continue
         enddo elem
      else
! wildcard, ignore references
         continue
      endif
   enddo sublat
   goto 300
!------------------------------------------------------------
! ionic liquid special, 2 sublattices but sites varies with charges
210 continue
   ie=0
   jsp=endm(1)
   if(jsp.gt.0) then
      pqval(2)=splista(jsp)%charge
   else
      pqval(2)=one
   endif
   jsp=endm(2)
   if(jsp.gt.0) then
      if(btest(splista(jsp)%status,SPVA)) then
         pqval(1)=one
      else
         pqval(1)=-splista(jsp)%charge
         if(pqval(1).eq.zero) then
            noelin1=.TRUE.
            pqval(2)=one
         endif
      endif
   else
      write(*,*)'Illegal with wildcards in 2nd sublattice'
      gx%bmperr=7777; goto 1000
   endif
   ionsl: do ll=1,2
      jsp=endm(ll)
      if(jsp.lt.0) cycle
      nrel=splista(jsp)%noofel
      ionel: do ik=1,nrel
         do je=1,ie
            if(splista(jsp)%ellinks(ik).eq.element(je)) then
               coef(je)=coef(je)+&
                    pqval(ll)*splista(jsp)%stoichiometry(ik)
               cycle ionel
            endif
         enddo
! new element, increment ie and initiate coef
! ignore the element VA with element index 0
         if(splista(jsp)%ellinks(ik).ne.0) then
            ie=ie+1
            element(ie)=splista(jsp)%ellinks(ik)
            coef(ie)=&
                 pqval(ll)*splista(jsp)%stoichiometry(ik)
            endif
      enddo ionel
   enddo ionsl
!------------------------------------------------------------
! sort the elements
300 continue
   more=0
   do je=1,ie-1
      if(element(je).gt.element(je+1)) then
         is=element(je)
         element(je)=element(je+1)
         element(je+1)=is
         xx=coef(je)
         coef(je)=coef(je+1)
         coef(je+1)=xx
         more=1
      endif
   enddo
   if(more.gt.0) goto 300
! list the elemsnts as -10*H298(SER,element)
!    write(*,*)'subrefstate 2:',ie,(element(i),i=1,ie)
   ip=1
   text=' '
   do je=1,ie
      if(coef(je).ne.one) then
         call wrinum(text,ip,10,6,-coef(je))
         text(ip:ip)='*'
      else
         text(ip:ip)='-'
      endif
      ip=ip+1
      lokel=element(je)
      els=ellista(lokel)%symbol
      if(ellista(lokel)%refstatesymbol.eq.0) then
         text(ip:)='H298(SER,'//els(1:len_trim(els))//')'
      else
         text(ip:)='G(SER,'//els(1:len_trim(els))//')'
      endif
      ip=len_trim(text)+1
   enddo
!    write(*,*)'subrefstate 9: ',ip,text(1:ip)
   funexpr(jp:)=text
   jp=jp+ip
1000 continue
   return
 end subroutine subrefstates

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine encode_stoik(text,ipos,spno)
! generate a stoichiometric formula of species from element list
   implicit none
   integer ipos,spno
   character text*(*)
!\end{verbatim}
   character elnam*2,ltext*60
   integer eli,noelx,iel,isto,jpos,ich,nlen
   double precision stoi,charge
   if(spno.lt.1 .or. spno.gt.noofsp) then
!       write(*,*)'in encode_stoik'
      gx%bmperr=4051
      goto 1000
   endif
   ipos=1
   noelx=splista(spno)%noofel
!  write(6,*)'encode_stoik 1: ',spno,noelx
   loop1: do iel=1,noelx
      eli=splista(spno)%ellinks(iel)
      elnam=ellista(eli)%symbol
!     write(6,*)'encode_stoik 2: ',eli,elnam
      if(elnam(2:2).ne.' ') then
         ltext(ipos:ipos+1)=elnam
         nlen=2
      else
         ltext(ipos:ipos)=elnam
         nlen=1
      endif
      ipos=ipos+nlen
      stoi=splista(spno)%stoichiometry(iel)
      isto=int(stoi)
      if(abs(dble(isto)-stoi).lt.1.0D-3) then
! handle integer stoichiometries nicely
         if(isto.gt.99) then
            write(ltext(ipos:ipos+2),200)isto
200         format(I3)
            ipos=ipos+3
         elseif(isto.gt.9) then
            write(ltext(ipos:ipos+1),205)isto
205         format(I2)
            ipos=ipos+2
         elseif(isto.gt.1) then
            write(ltext(ipos:ipos),210)isto
210          format(i1)
            ipos=ipos+1
!           write(6,*)'encode_stoik 4B: ',ltext(ipos-3:ipos)
         elseif(nlen.eq.1 .and. iel.ne.noelx) then
            ltext(ipos:ipos)='1'
            ipos=ipos+1
         endif
      else
! stoichiometry is a non-integer value
         jpos=ipos
         call wrinum(ltext,ipos,8,0,stoi)
         if(buperr.ne.0) then
            gx%bmperr=buperr; goto 1000
         endif
! remove trailing zeroes
300       continue
         if(ltext(ipos:ipos).eq.'0') then
            ipos=ipos-1; goto 300
         endif
      endif
   enddo loop1
   charge=splista(spno)%charge
   ich=int(charge)
!  write(6,*)'encode_stoik 5: ',ich,charge
   if(ich.lt.zero) then
! limit output to integer charges <10
      ltext(ipos:ipos+3)='/-'//char(ichar('0')-ich)
      ipos=ipos+3
   elseif(charge.gt.zero) then
      ltext(ipos:ipos+3)='/+'//char(ichar('0')+ich)
      ipos=ipos+3
   endif
   text=ltext
   ipos=ipos-1
!  write(6,*)'encode_stoik 6: ',ipos,ltext(1:ipos)
1000 continue
   return
 END subroutine encode_stoik

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine decode_stoik(name,noelx,elsyms,stoik)
! decode a species stoichiometry in name to element index and stoichiometry
! all in upper case
   implicit none
   character name*(*),elsyms(*)*2
   double precision stoik(*)
   integer noelx
!\end{verbatim}
   character lname*72,ch2*2
   double precision xx
   integer ip,jp
   lname=name
   call capson(lname)
   noelx=0
   ip=1
! expect element symbol
   if(eolch(lname,ip)) then
! empty line, expected species stoichiometry
      gx%bmperr=4083; goto 1000
   endif
!    write(*,*)'decode_stoik 1: ',lname
100 continue
   ch2=lname(ip:ip+1)
!   write(*,*)'Looking for element: ',ip,ch2
   if(ch2(2:2).ge.'A' .and. ch2(2:2).le.'Z') then
      noelx=noelx+1
      elsyms(noelx)=ch2
      ip=ip+2
   elseif(ch2(1:1).ge.'A' .and. ch2(1:1).le.'Z') then
      noelx=noelx+1
      elsyms(noelx)=ch2(1:1)
      ip=ip+1
   elseif(ch2(1:1).eq.'/') then
! electron is always /-, if /+ is given change sign in lname
      noelx=noelx+1
      elsyms(noelx)='/-'
      if(ch2(2:2).eq.'+') then
         lname(ip+1:ip+1)='-'
         ip=ip+1
      elseif(ch2(2:2).eq.'-') then
         ip=ip+2
      else
! do not accept Fe/2 for Fe/+2, always require + or -
         write(*,*)'Charge must always be given as /+ or /-'
         gx%bmperr=7777; goto 1000
      endif
!      write(*,*)'Found charge: ',ip,noelx,'>',lname(ip:ip+5),'<'
   else
      goto 900
   endif
! an element found, no stoichiometry number means stoik=1
!    write(*,17)'decode_stoik 2: ',ip,ch2,lname(ip:ip+5)
17 format(a,i3,'>',a,'<>',a,'<')
   if(lname(ip:ip).eq.' ') then
      stoik(noelx)=one
   else
      jp=ip
      call getrel(lname,ip,xx)
!      write(*,*)'decode_stoik 3: ',jp,ip,buperr,xx
      if(buperr.eq.0) then
         stoik(noelx)=xx
      else
! accept missing stoichiometry value as 1, it is accepted to write cao as cao
         stoik(noelx)=one
!         buperr=0
! the error can be due to another element follows directly, restore ip an check
!         ip=jp
!         goto 100
      endif
! in one case of missing stoichiometry ip exceeded length of lname
!       write(*,*)'decode_stoik 4: ',stoik(noelx)
      fraction: if(buperr.eq.0 .and. lname(ip:ip).eq.'/') then
! a stoichiometric factor followed by / without sign will be interpreted
! as a fraction like AL2/3O.  Note AL2/+3 means AL2 with charge +3
         jp=ip+1
         if(.not.(lname(jp:jp).eq.'+' .or. lname(jp:jp).eq.'-')) then
            call getrel(lname,jp,xx)
!            write(*,*)'decode_stoik 4: ',ip,jp,buperr,xx
            if(buperr.eq.0) then
               stoik(noelx)=stoik(noelx)/xx
               ip=jp
            else
               buperr=0
            endif
!         else
!            write(*,*)'Interpret / as charge!'
         endif
      else
         buperr=0
      endif fraction
      if(ip.lt.len(lname)) goto 100
   endif
900 continue
   if(noelx.eq.0) then
      gx%bmperr=4084
   endif
!    write(*,19)(stoik(i),i=1,noelx)
!19 format('decode_stoik 5: ',5(1PE12.3))
1000 continue
   return
 end subroutine decode_stoik

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine encode_constarr(constarr,nsl,endm,nint,lint,ideg)
! creates a constituent array
   implicit none
   character constarr*(*)
   integer, dimension(*) :: endm
   integer nsl,nint,ideg
   integer, dimension(2,*) :: lint
!\end{verbatim}
   integer ip,mint,ll,l2
   ip=1
   constarr=' '
   mint=1
!  if(nint.gt.0) then
!     write(*,*)'encode_contarr ',lint(1,1),lint(2,1)
!  endif
   do ll=1,nsl
      if(endm(ll).gt.0) then
         constarr(ip:)=splista(endm(ll))%symbol
      else
         constarr(ip:)='*'
      endif
      ip=len_trim(constarr)
      if(mint.le.nint) then
!        write(*,*)'encode_contarr ',lint(1,1),lint(2,1)
         do l2=mint,nint
            if(lint(1,mint).eq.ll) then
               constarr(ip+1:ip+1)=','
               ip=ip+2
               constarr(ip:)=splista(lint(2,mint))%symbol
               ip=len_trim(constarr)
               mint=mint+1
            endif
         enddo
      endif
      constarr(ip+1:ip+1)=':'
      ip=ip+2
   enddo
   constarr(ip-1:ip-1)=';'
   constarr(ip:ip)=char(ideg+ichar('0'))
   return
 end subroutine encode_constarr

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine decode_constarr(lokph,constarr,nsl,endm,nint,lint,ideg)
! deconde a text string with a constituent array
! a constituent array has <species> separated by , or : and ; before degree
   implicit none
   character constarr*(*)
   integer endm(*),lint(2,*)
   integer nsl,nint,ideg,lokph,lord
!\end{verbatim}
   character const*24,ch1*1
   integer ll,ip,jp,isep,loksp,mord,isp,jsp,nord
   integer constlist(5),klok(5),knr(2)
!
   nint=0; ideg=0; ll=1
   endm(ll)=0
   ip=1
! write(*,*)'decode_constarr 1: ',ip,constarr
   if(eolch(constarr,ip)) then
      gx%bmperr=4061; goto 1000
   endif
   jp=ip-1
!  write(*,*)'decode_constarr 2: ',ip,jp
   loop: do while(.true.)
! find separators between constituents, no spaces allowed
      jp=jp+1
      ch1=biglet(constarr(jp:jp))
!       write(*,*)'decode_constarr 3: ',jp,ch1
      letter: if(ch1.eq.',') then
         isep=1
      elseif(ch1.eq.':') then
         isep=2
      elseif(ch1.eq.';') then
         isep=3
      elseif(ch1.eq.' ') then
         isep=4
      elseif(.not.(ch1.ge.'A' .and. ch1.le.'Z')) then
!          write(*,*)'decode_constarr 3B: ',jp,ip,ch1
         if(jp.gt.ip) then
! accept 0-9 and _ and . and / and + and - 
! after the first character of a constituent
!             write(*,24)'decode constarr 24A: "',ch1
            if(.not.((ch1.ge.'0' .and. ch1.le.'9') .or. &
                 ch1.eq.'_' .or. ch1.eq.'.' .or. &
                 ch1.eq.'/' .or. ch1.eq.'+' .or. ch1.eq.'-')) then
!               write(*,24)'25E: decode constarr 24B: "',ch1
24             format(a,a,'"')
               gx%bmperr=4062; goto 1000
            endif
         elseif(ch1.ne.'*') then
! last possibility: wildcard
!             write(*,24)'decode constarr 24C: "',ch1
            gx%bmperr=4062; goto 1000
         endif
!          write(*,24)'decode constarr 24D: "',ch1
         cycle
      else
         cycle
      endif letter
! we have a species name between ip and jp
      const=constarr(ip:jp-1)
      call find_species_record_exact(const,loksp)
      if(gx%bmperr.ne.0) then
         if(const(1:2).eq.'* ') then
! wildcard, the parameter is independent of the fraction in this sublattice
            loksp=-99; gx%bmperr=0
         else
            goto 1000
         endif
      endif
!       write(*,11)'decode constarr 11: ',ip,jp,loksp,const
!11     format(a,3i4,'"',a,'"')
      place: if(endm(ll).eq.0) then
! first constituent of sublattice ll independent of separator
         endm(ll)=loksp
      else
         lint(1,nint)=ll
         lint(2,nint)=loksp
      endif place
      next: if(isep.eq.1) then
! separator was a , next constituent an interaction
         nint=nint+1
      elseif(isep.eq.2) then
!  separator was a ":" meaning new sublattice
         ll=ll+1
         endm(ll)=0
      elseif(isep.eq.3) then
! this is end of constituent array, followed ba a degree 0-9
         ideg=ichar(constarr(jp+1:jp+1))-ichar('0')
         if(ideg.lt.0 .or. ideg.gt.9) then
! a degree must be between 0 and 9
            gx%bmperr=4063; goto 1000
         endif
         exit loop
      elseif(isep.eq.4) then
         exit loop
      endif next
! beginning of next constituent
      ip=jp+1
   enddo loop
! number of sublattices
   nsl=ll
! make sure the constituents are in alphabetcal order for each sublattice.
!--------------------------------------------------------
! Special order of constituents for ionic liquid ....
   if(btest(phlista(lokph)%status1,PHIONLIQ)) then
      constlist(1)=endm(1)
      if(nsl.ne.2) then
         if(nsl.eq.1) then
! when ionic liquid parameters entered from TDB-TC files parameters
! with just neutrals may have only one sublattice.  Error cleared by
! the readtdb subroutine.  
! BUT we must sort constituents on the sublattice, must be only neutrals ...
! I hope that will be chacked later ...
            do jsp=1,nint
               constlist(1+jsp)=lint(2,jsp)
            enddo
! simple bubble sort of constlist
44          continue
            do jsp=1,nint
               if(constlist(jsp+1).lt.constlist(jsp)) then
                  lord=constlist(jsp)
                  constlist(jsp)=constlist(jsp+1)
                  constlist(jsp+1)=lord
                  goto 44
               endif
            enddo
         endif
         endm(1)=constlist(1)
         do jsp=1,nint
            lint(2,jsp)=constlist(1+jsp)
         enddo
         if(ocv()) write(*,*)'Ionic liquid has always 2 sublattices'
         gx%bmperr=7777; goto 1000
      endif
      lord=1
      do jsp=1,nint
         if(lint(1,jsp).eq.1) then
            lord=lord+1
            constlist(lord)=lint(2,jsp)
         endif
      enddo
      knr(1)=lord
      lord=lord+1
      constlist(lord)=endm(2)
      do jsp=1,nint
         if(lint(1,jsp).eq.2) then
            lord=lord+1
            constlist(lord)=lint(2,jsp)
         endif
      enddo
      knr(2)=lord-knr(1)
      call sort_ionliqconst(lokph,1,knr,constlist,klok)
      if(gx%bmperr.ne.0) then
         write(*,*)'Error return from sort_ionliqconst ',gx%bmperr
         goto 1000
      endif
!      write(*,65)lord,(klok(ll),ll=1,lord)
65    format('from sort: ',i5,5x,5i3)
      lord=0
      endm(1)=klok(1)
      do jsp=2,knr(1)
         lord=lord+1
         lint(1,lord)=1
         lint(2,lord)=klok(lord+1)
      enddo
      endm(2)=klok(lord+2)
      do jsp=2,knr(2)
         lord=lord+1
         lint(1,lord)=2
         lint(2,lord)=klok(lord+2)
      enddo
!      write(*,66)endm(1),endm(2),(lint(1,ll),lint(2,ll),ll=1,nint)
66    format('decode: ',2i5,5x,3(2i3,2x))
      goto 1000
   endif
!--------------------------------------------------------
! first the endmember must be in order of the constituents, except wildcard
   order1: do mord=1,nint
      ll=lint(1,mord)
      isp=lint(2,mord)
      jsp=endm(ll)
! we can have isp or jsp or both negative if wildcard, WILDCARD ALWAYS IN ENDM
      if(isp.lt.0 .and. jsp.lt.0) then
! only one wildcard in each sublattice
         gx%bmperr=4032; goto 1000
      elseif(isp.lt.0 .and. jsp.gt.0) then
         endm(ll)=isp
         lint(2,mord)=jsp
      elseif(isp.gt.0 .and. jsp.lt.0) then
         endm(ll)=jsp
         lint(2,mord)=isp
      elseif(splista(isp)%alphaindex.lt.splista(jsp)%alphaindex) then
         endm(ll)=isp
         lint(2,mord)=jsp
      endif
   enddo order1
! then order if there are two interacting in same sublattice
! There are almost never more than 3 constituents interacting in one sublattice
   order2: do mord=1,nint
      ll=lint(1,mord)
      order3: do nord=mord+1,nint
         if(lint(1,nord).eq.ll) then
            isp=lint(2,nord)
            jsp=lint(2,mord)
            if(isp.lt.0 .or. jsp.lt.0) then
               gx%bmperr=4032; goto 1000
            endif
            if(splista(isp)%alphaindex.lt.splista(jsp)%alphaindex) then
               lint(2,mord)=isp
               lint(2,nord)=jsp
            endif
         endif
      enddo order3
   enddo order2
!  write(*,77)(splista(endm(i))%alphaindex,i=1,nsl), &
!       (lint(1,j),lint(2,j),j=1,nint)
!77 format('decode_contarr 7: ',3I3,5x,2i2)
1000 continue
   return
 end subroutine decode_constarr

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
! changed from list_references(lut)
 subroutine list_bibliography(lut)
! list bibliographic references
   implicit none
   integer lut
!\end{verbatim}
   character longline*2048
   integer ir,jp,nl,ll
   write(lut,10)reffree-1
10  format('There are ',i5,' bibliographic references')
   do ir=1,reffree-1
      longline=bibrefs(ir)%reference
      jp=17
      nl=size(bibrefs(ir)%refspec)
!       write(*,11)nl,bibrefs(ir)%reference
!11     format('refslist 1: ',i2,1x,a)
      do ll=1,nl
         longline(jp:)=bibrefs(ir)%refspec(ll)
!          write(*,12)ll,bibrefs(ir)%refspec(ll)
!12        format('refslist 2: ',i2,1x,a)
         jp=jp+64
      enddo
      jp=len_trim(longline)
      call wrice(lut,0,17,78,longline(1:jp))
   enddo
1000 continue
   return
 end subroutine list_bibliography

!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\!/!\

!\begin{verbatim}
 subroutine list_conditions(lut,ceq)
! lists conditions on lut
   implicit none
   integer lut
   type(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   character*1024 text
   integer kl
   text=' '
   call get_all_conditions(text,0,ceq)
   if(gx%bmperr.ne.0) goto 1000
   kl=index(text,'CRLF')
   if(kl.gt.1) then
      call wrice2(lut,2,4,78,1,text(1:kl-1))
   endif
   write(lut,50)text(kl+4:len_trim(text))
50 format(a)
1000 continue
   return
 end subroutine list_conditions

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

!\begin{verbatim}
 subroutine get_one_condition(ip,text,seqz,ceq)
! list the condition with the index seqz into text
! It lists also fix phases and conditions that are not active
   implicit none
   integer ip,seqz
   character text*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   integer jl,iterm,indx(4)
   TYPE(gtp_condition), pointer :: last,current
   type(gtp_state_variable), pointer :: svrrec
   double precision wone
!
   if(ip.le.0) ip=1
   text(ip:)=' '
   if(.not.associated(ceq%lastcondition)) then
      write(*,*)'No conditions at all'
      gx%bmperr=8887; goto 1000
   endif
   last=>ceq%lastcondition
   current=>last
70 continue
      if(current%seqz.eq.seqz) goto 100
      current=>current%next
      if(.not.associated(current,last)) goto 70
! no condition with this index found
      gx%bmperr=4131; goto 1000
!
100 continue
   iterm=1
! return here for each term if several
150 continue
   do jl=1,4
      indx(jl)=current%indices(jl,iterm)
   enddo
   if(abs(current%condcoeff(iterm)-one).gt.1.0D-10) then
      wone=current%condcoeff(iterm)+one
      if(abs(wone).lt.1.0D-10) then
         text(ip:ip)='-'
         ip=ip+1
      else
! not +1 or -1, write number
         call wrinum(text,ip,8,1,current%condcoeff(iterm))
         text(ip:ip)='*'
         ip=ip+1
      endif
   elseif(iterm.gt.1) then
! must be a + in front of second and later terms
      text(ip:ip)='+'
      ip=ip+1
   endif
! why is ceq needed?? BECAUSE COMPONENTS CAN BE DIFFERENT   ... hm?? !! 
!   call encode_state_variable2(text,ip,current%statev,indx,&
!        current%iunit,current%iref,ceq)
   svrrec=>current%statvar(1)
   call encode_state_variable(text,ip,svrrec,ceq)
   if(iterm.lt.current%noofterms) then
      iterm=iterm+1; goto 150
   endif
! write = followed by the value 
   if(text(ip:ip).ne.' ') ip=ip+1
   text(ip:)='='
   ip=ip+1
   if(current%symlink1.gt.0) then
! the value is a symbol
      text(ip:)=svflista(current%symlink1)%name
      ip=len_trim(text)+1
   else
      call wrinum(text,ip,10,0,current%prescribed)
   endif
1000 continue
   return
 end subroutine get_one_condition

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

!\begin{verbatim}
 subroutine get_all_conditions(text,mode,ceq)
! list all conditions if mode=0, experiments if mode=1
   implicit none
   integer mode
   character text*(*)
   TYPE(gtp_equilibrium_data), pointer :: ceq
!\end{verbatim}
   TYPE(gtp_condition), pointer :: last,current,first
   type(gtp_state_variable), pointer :: svrrec
   character phname*32
   integer ntot,nc,ip,iterm,iph,ics,jl
   double precision value,wone
   integer indx(4)
   ntot=0
   text=' '
   if(mode.eq.1) then
! cannot enter experiments yet
      goto 1000
   endif
   if(noofel.eq.0) then
      text='CRLF No elements'
      goto 1000
   endif
   last=>ceq%lastcondition
   if(.not.associated(last)) then
! The CRLF indicates CR+LF at output
      write(text,50)noofel+2
50    format('CRLF Degrees of freedom are ',i3)
      goto 1000
   endif
   current=>last%next
   first=>current
   nc=1
   ip=1
100 continue
! conditions can also be fixed phases !!!
   ntot=ntot+1
   if(current%active.ne.0) then
! if active is nonzero the condition is not active
      goto 200
   endif
!   call wrinum(text,ip,3,0,dble(nc))
   call wriint(text,ip,nc)
! number the conditions
   text(ip:)=':'
!   ip=ip+2
! No space after :
   ip=ip+1
   iterm=1
   if(current%statev.lt.0) then
! handle FIX phases
      iph=-current%statev
      ics=current%iref
      call get_phase_name(iph,ics,phname)
      if(gx%bmperr.ne.0) then
         write(*,*)'list condition error for phase ',iph,ics
         gx%bmperr=4178; goto 1000
      endif
      text(ip:)='<'//phname
      ip=len_trim(text)+3
      text(ip-2:ip-1)='>='
      value=current%prescribed
      if(value.lt.1.0d-8) then
         value=zero
      endif
      call wrinum(text,ip,4,0,value)
      goto 190
   endif
! return here for each term if several
150 continue
   do jl=1,4
      indx(jl)=current%indices(jl,iterm)
   enddo
   if(abs(current%condcoeff(iterm)-one).gt.1.0D-10) then
      wone=current%condcoeff(iterm)+one
      if(abs(wone).lt.1.0D-10) then
         text(ip:ip)='-'
         ip=ip+1
      else
! not +1 or -1, write number
!         write(*,*)'list cond: ',current%condcoeff(iterm),one,wone
         call wrinum(text,ip,8,1,current%condcoeff(iterm))
         text(ip:ip)='*'
         ip=ip+1
      endif
   elseif(iterm.gt.1) then
! must be a + in front of second and later terms
      text(ip:ip)='+'
      ip=ip+1
   endif
! why is ceq needed?? BECAUSE COMPONENTS CAN BE DIFFERENT   ... hm?? !! 
!   write(*,*)'25E encode: ',current%statev,indx
!   call encode_state_variable2(text,ip,current%statev,indx,&
!        current%iunit,current%iref,ceq)
   svrrec=>current%statvar(1)
   call encode_state_variable(text,ip,svrrec,ceq)
   if(iterm.lt.current%noofterms) then
      iterm=iterm+1; goto 150
   endif
! problem with current position ... LNAC(CR) had the last ) overwritten ...
!   write(*,157)ip,text(1:ip)
!157 format('25E gc: ',i2,'"',a,'"')
   if(text(ip:ip).ne.' ') ip=ip+1
   text(ip:)='='
   ip=ip+1
   if(current%symlink1.gt.0) then
! the value is a symbol
      text(ip:)=svflista(current%symlink1)%name
      ip=len_trim(text)+1
   else
      call wrinum(text,ip,10,0,current%prescribed)
   endif
190 continue
   text(ip:ip)=', '
   ip=ip+2
   nc=nc+1
200 continue
   current=>current%next
   if(.not.associated(current,first)) goto 100
! there can be non-active conditions only
   if(nc.gt.1) then
! write without the last ,
      text(ip-2:)=' '
!      write(kou,99)text(1:ip-3)
!99    format(a)
   endif
   write(text(ip:),50)noofel+3-nc
1000 return
 end subroutine get_all_conditions

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

!\begin{verbatim}
 subroutine list_defined_properties(lut)
! lists all parameter identifiers allowed
   implicit none
   integer lut
!\end{verbatim}
   character special*32,tdep*1,pdep*1
   integer typty,kk
   write(lut,10)
10 format('Index Ident  T P Specification',23x,' Status Note')
!10 format('Index  Symbol Specification',26x,' Status Note')
   do typty=1,ndefprop
      special=' '
      if(btest(propid(typty)%status,IDELSUFFIX)) then
         special='&<element>'
      elseif(btest(propid(typty)%status,IDCONSUFFIX)) then
         special='&<constituent#sublattice>'
      endif
      kk=len_trim(special)
      if(kk.gt.0) then
         special(kk+1:)=';'
         kk=kk+2
      else
         kk=1
      endif
      tdep='T'
      pdep='P'
      if(btest(propid(typty)%status,IDNOTP)) then
!         special(kk:)='Not T- and P-dependent'
         tdep='-'
         pdep='-'
      elseif(btest(propid(typty)%status,IDONLYP)) then
!         special(kk:)='Not T-dependant'
         tdep='-'
      endif
      write(lut,50)typty,propid(typty)%symbol,tdep,pdep,special,&
           propid(typty)%status,propid(typty)%note
50    format(i5,2x,a,2x,a,1x,a,2x,a,2x,z8,1x,a)
   enddo
1000 continue
   return
 end subroutine list_defined_properties

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

!\begin{verbatim}
 subroutine find_defined_property(symbol,mode,typty,iph,ics)
! searches the propid list for one with symbol or identifiction typty
! if mode=0 then symbol given, if mode=1 then typty given
! symbol can be TC(BCC), BM(FCC), MQ&FE(HCP) etc, the phase must be 
! given in symbol as otherwise it is impossible to find the consititent!!!
! A constituent may have a sublattice specifier, MQ&FE#3(SIGMA)
   implicit none
   integer mode,typty,iph,ics
   character symbol*(*)
!\end{verbatim}
   character phsym*24,specid*24,nude*4
   integer splink,k1,k2,lattice,lokph,ityp,iel,kk,ll,jj
   integer jtyp
!   write(*,7)'25E fdp 1: ',symbol(1:5),mode,typty,iph,ics
7  format(a,a,5i5)
   if(mode.eq.0) then
! symbol given, can include & # and ( ) like MQ&FE#3(SIGMA)
      lattice=0
      nude=' '
      specid=' '
      k1=index(symbol,'&')
      if(k1.gt.0) then
         nude=symbol(1:k1-1)
         k2=index(symbol,'#')
         if(k2.eq.0) then
            k2=index(symbol,'(')
            if(k2.eq.0) then
!               write(*,*)'25E: Missing phase specifier in property symbol 1'
               write(*,*)'Error in symbol: ',symbol
               gx%bmperr=7777; goto 1000
            endif
         else
            lattice=ichar(symbol(k2+1:k2+1))-ichar('0')
            if(lattice.le.0 .or. lattice.gt.9) then
               write(*,*)'Sublattice outside range in property symbol'
               gx%bmperr=7777; goto 1000
            endif
         endif
         specid=symbol(k1+1:k2-1)
         call capson(specid)
      endif
! there must be a phase name within ( )
      k1=index(symbol,'(')
      if(k1.gt.0) then
         k2=index(symbol,')')
         if(k2.lt.k1) then
            write(*,*)'25E Missing phase specifier in property symbol 2'
            write(*,*)'Symbol: ',symbol
            gx%bmperr=7777; goto 1000
         endif
         phsym=symbol(k1+1:k2-1)
         call find_phase_by_name(phsym,iph,ics)
         if(gx%bmperr.ne.0) goto 1000
         lokph=phases(iph)
         if(nude(1:1).eq.' ') nude=symbol(1:k1-1)
      elseif(mode.ne.0) then
         write(*,*)'25E Missing phase specifier in property symbol 3'
         write(*,*)'Symbol: ',symbol,mode
         gx%bmperr=7777; goto 1000
!      else
! mode=0 means just ignore
!         write(*,*)'25E mode: ',mode,iph,ics
!         goto 1000
      endif
! now nude is the property id, lokph is phase location, specid is element or
! constituent symbol, lattice is sublattice number
! skip index 1 as G is a state variable
      call capson(nude)
!      write(*,*)'fdp 2: ',iph,ics,nude
      do ityp=2,ndefprop
!         write(*,*)'fdp 3: ',ityp,nude,propid(ityp)%symbol
         if(propid(ityp)%symbol.ne.nude) cycle
         if(btest(propid(ityp)%status,IDELSUFFIX)) then
! element specifier, IBM&CR(BCC) (when we have element specific Bohr magnetons)
!            write(*,*)'fdp 4: element: ',specid
            call find_element_by_name(specid,iel)
            if(gx%bmperr.ne.0) goto 1000
            typty=100*ityp+iel
            goto 200
         elseif(btest(propid(ityp)%status,IDCONSUFFIX)) then
! constituent specifier, for example: MQ&FE#3(SIGMA)
!            write(*,*)'fdp 5: constituent: ',specid
            kk=0
            do ll=1,phlista(lokph)%noofsubl
               do jj=1,phlista(lokph)%nooffr(ll)
                  kk=kk+1
                  splink=phlista(lokph)%constitlist(kk)
                  if(splink.le.0) then
                     write(*,*)'Illegal use of woildcard 3'
                     gx%bmperr=7777; goto 1000
                  endif
                  if(specid.eq.splista(splink)%symbol .and. &
                       (lattice.eq.0 .or. lattice.eq.ll)) then
                     typty=100*ityp+kk
                     goto 200
                  endif
               enddo
            enddo
         else
! property without specifier like TC(FCC)
            typty=ityp
            goto 200
         endif
      enddo
! if we come here we have not found the constituent or element or property
! it may be OK anyway if this is a call to test if symbol exists ??
!      write(*,*)'25E Illegal property symbol'
      gx%bmperr=7777; goto 1000
! we must return property number, phase location, element
! the value TYPTY stored in property records is "idprop" or
! if IDELSUFFIX set then 100*"idprop"+ellista index of element
! if IDCONSUFFIX set then 100*"idprop"+constituent index
200   continue
   else
! indices given, typty, iph and ics, construct the symbol
! if typty>100 there is also an element or constituent specifier
      lokph=phases(iph)
!      write(*,*)'fdp 10: ',typty,iph,ics,lokph
      ityp=typty
      jtyp=-1
      if(ityp.gt.100) then
         ityp=typty/100
         jtyp=typty-100*ityp
      endif
      if(ityp.le.1 .or. ityp.gt.ndefprop) then
         write(*,*)'Property number outside range ',typty
         gx%bmperr=7777; goto 1000
      endif
      symbol=propid(ityp)%symbol
      if(btest(propid(ityp)%status,IDELSUFFIX)) then
! could one have /- as specifier??? NO !! But maye Va
         if(jtyp.lt.0) then
            write(*,*)'Missing element index in property symbol'
            gx%bmperr=7777; goto 1000
         endif
         if(jtyp.lt.0 .or. jtyp.gt.noofel) then
            write(*,*)'Too high element index in property symbol'
            gx%bmperr=7777; goto 1000
         endif
         symbol=symbol(1:len_trim(symbol))//'&'//ellista(jtyp)%symbol
      elseif(btest(propid(ityp)%status,IDCONSUFFIX)) then
         if(jtyp.lt.0) then
            write(*,*)'Missing constituent index in property symbol'
            gx%bmperr=7777; goto 1000
         endif
         if(iph.le.0 .or. iph.gt.noofph) then
            write(*,*)'Illegal phase location in property symbol'
            gx%bmperr=7777; goto 1000
         endif
         kk=0
         do ll=1,phlista(lokph)%noofsubl
            do jj=1,phlista(lokph)%nooffr(ll)
               kk=kk+1
               if(kk.eq.jtyp) then
                  splink=phlista(lokph)%constitlist(kk)
                  if(splink.le.0) then
                     write(*,*)'Illegal use of woildcard 4'
                     gx%bmperr=7777; goto 1000
                  endif
                  specid=splista(splink)%symbol
                  if(ll.gt.1) then
                     specid=specid(1:len_trim(specid))//&
                          '#'//char(ichar('0')+ll)
                  endif
                  goto 400
               endif
            enddo
         enddo
! we come here is we failed to find the constituent
         write(*,*)'Illegal constituent index in property symbol'
         gx%bmperr=7777; goto 1000
400      continue
         symbol=symbol(1:len_trim(symbol))//'&'//specid
      elseif(jtyp.gt.0) then
         write(*,*)'This property has no specifier'
         gx%bmperr=7777; goto 1000
      endif
! add the phase
!      write(*,*)'fdp 11: ',lokph,ics
      symbol=symbol(1:len_trim(symbol))//'('//phlista(lokph)%name
      if(ics.lt.0 .or. ics.gt.phlista(lokph)%noofcs) then
         write(*,*)'No such composition set'
         gx%bmperr=7777; goto 1000
      endif
      if(ics.gt.1) symbol=symbol(1:len_trim(symbol))//'#'//char(ichar('0')+ics)
      symbol=symbol(1:len_trim(symbol))//')'
!      write(*,*)'fdp 12: ',symbol(1:20)
   endif
1000 continue
   return
 end subroutine find_defined_property

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

!\begin{verbatim}
 subroutine list_equilibria_details(mode,teq)
   implicit none
   TYPE(gtp_equilibrium_data), pointer :: teq
   integer mode
!\end{verbatim}
   TYPE(gtp_equilibrium_data), pointer :: ceq
!   TYPE(gtp_phase_varres) :: varres
   integer ieq,noofeq,iph
   noofeq=noeq()
   select case(mode)
   case default
      write(*,*)'No such mode: ',mode
!--------------------------------------------------
   case(1) ! list equilibria and some general data
      write(*,10)noofeq
10    format('Number of equilibria: ',i3)
      do ieq=1,noofeq
         ceq=>eqlista(ieq)
         write(*,11)ceq%eqno,ceq%eqname
11       format('Equilibrium ',i3,', ',a)
      enddo
!--------------------------------------------------
   case(100:199) ! list phase varres data for phase mod(mode,100)
      iph=mod(mode,100)
      if(iph.eq.0) then
         write(*,*)'all phases'
      else
         write(*,*)'phase ',iph
      endif
   end select
1000 continue
   return
 end subroutine list_equilibria_details

!/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\/!\

